# [算法入门](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=308)

## 01数据结构

### 栈

#### AB1【模板】栈

描述
请你实现一个栈。
操作：
push x：将 加x\x 入栈，保证 x\x 为 int 型整数。
pop：输出栈顶，并让栈顶出栈
top：输出栈顶，栈顶不出栈
输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。

输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若栈为空，则输出 "error“
否则按对应操作输出。

示例1

```
输入：
6
push 1
pop
top
push 2
push 3
pop

输出：
1
error
3
```

思路
step1：首先初始化栈（第1至13行）
step2：创建栈s，同时输入执行命令次数，按次数执行指令；
step3：按照题目要求，满足要求；
代码如下：

```
class Stack():
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def push(self,item):
        self.items.append(item)
    def pop(self):
        return self.items.pop()
    def peek(self):
        return self.items[len(self.items) - 1]
    def size(self):
        return self.items[len(self.items)]
    
s = Stack()
num = int(input())
for i in range(num):
    a=input()
    if a[0:4] == 'push':
        b = a.split(' ')
        s.push(int(b[1]))
    if a == 'pop':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
            s.pop()
    if a == 'top':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
```

#### AB2 栈的压入、弹出序列

描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
1. 0<=pushV.length == popV.length <=1000
2. -1000<=pushV[i]<=1000
3. pushV 的所有数字均不相同
示例1

示例1

```
输入：[1,2,3,4,5],[4,5,3,2,1]
返回值：true
说明：可以通过push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true   
```

示例2

```
输入：[1,2,3,4,5],[4,3,5,1,2]
返回值：false
说明：由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false      
```

方法一：辅助栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

题目要我们判断两个序列是否符合入栈出栈的次序，我们就可以用一个栈来模拟。对于入栈序列，只要栈为空，序列肯定要依次入栈。那什么时候出来呢？自然是遇到一个元素等于当前的出栈序列的元素，那我们就放弃入栈，让它先出来。

```
//入栈：栈为空或者栈顶不等于出栈数组
while(j < n && (s.isEmpty() || s.peek() != popA[i])){
    s.push(pushA[j]);
    j++;
}
```

具体做法：

step 1：准备一个辅助栈，两个下标分别访问两个序列。
step 2：辅助栈为空或者栈顶不等于出栈数组当前元素，就持续将入栈数组加入栈中。
step 3：栈顶等于出栈数组当前元素就出栈。
step 4：当入栈数组访问完，出栈数组无法依次弹出，就是不匹配的，否则两个序列都访问完就是匹配的。
图示：

![7F25B229A4900F6E066BE03E92B0492E](/Users/zzy/Downloads/Chrome下载/7F25B229A4900F6E066BE03E92B0492E.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        n = len(pushV)
        #辅助栈
        s = []
        #遍历入栈的下标
        j = 0
        #遍历出栈的数组
        for i in range(n):
            #入栈：栈为空或者栈顶不等于出栈数组
            while j < n and (len(s) == 0 or s[-1] != popV[i]):
                s.append(pushV[j])
                j += 1
            #栈顶等于出栈数组
            if s[-1] == popV[i]:
                s.pop()
            #不匹配序列
            else:
                return False
        return True
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏情况下需要遍历两个数组各一次
空间复杂度：O(n)O(n)O(n)，辅助栈空间最大为一个数组的长度

方法二：原地栈（扩展思路）
思路：

方法一我们使用了一个辅助栈来模拟，但是数组本来就很类似栈啊，用下标表示栈顶。在方法一种push数组前半部分入栈了，就没用了，这部分空间我们就可以用来当成栈。原理还是同方法一一样，只是这时我们遍历push数组的时候，用下标n表示栈空间，n的位置就是栈顶元素。

具体做法：

step 1：用下标n表示栈空间，用j表示出栈序列的下标。
step 2：遍历每一个待入栈的元素，加入栈顶，即push数组中n的位置，同时增加栈空间的大小，即n的大小。
step 3：当栈不为空即栈顶n大于等于0，且栈顶等于当前出栈序列，就出栈，同时缩小栈的空间，即减小n。
step 4：最后若是栈空间大小n为0，代表全部出栈完成，否则不匹配。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        #表示栈空间的大小，初始化为0
        n = 0
        #出栈序列的下标
        j = 0
        #对于每个待入栈的元素
        for num in pushV:
            #加入栈顶
            pushV[n] = num
            #当栈不为空且栈顶等于当前出栈序列
            while n >= 0 and pushV[n] == popV[j]:
                #出栈，缩小栈空间
                j += 1
                n -= 1
            n += 1
        #最后的栈是否为空
        return True if n == 0 else False
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏还是遍历两个数组
空间复杂度：O(1)O(1)O(1)，常数级变量，无额外辅助空间

#### AB3 有效括号序列

描述
给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

数据范围：字符串长度 0\le n \le 100000≤n≤10000
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
示例1

```
输入："()[]{}"
返回值：true
```

示例2

```
输入："[]"
返回值：true
```

示例3

```
输入："([)]"
返回值：false
```

方法：栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

括号的匹配规则应该符合先进后出原理：最外层的括号即最早出现的左括号，也对应最晚出现的右括号，即先进后出，因此可以使用同样先进后出的栈：遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。

具体做法：

step 1：创建辅助栈，遍历字符串。
step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。
step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。
step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。
step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。
图示：

![4760A3E42ACB7E73D162BE2CD8C2E2C9](/Users/zzy/Downloads/Chrome下载/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return bool布尔型
#
class Solution:
    def isValid(self , s: str) -> bool:
        # write code here
        #辅助栈
        st = []
        #遍历字符串
        for i, char in enumerate(s):
            #遇到左小括号
            if char == '(':
                #期待遇到右小括号
                st.append(')')
            #遇到左中括号
            elif char == '[':
                #期待遇到右中括号
                st.append(']')
            #遇到左大括号
            elif char == '{':
                #期待遇到右大括号
                st.append('}')
            #必须有左括号的情况下才能遇到右括号
            elif (len(st) == 0):
                return False
            #右括号匹配则弹出
            elif (st[-1] == char):
                st.pop()
        #栈中是否还有元素
        return len(st) == 0
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为字符串长度，遍历整个字符串
空间复杂度：O(n)O(n)O(n)，最坏情况下栈空间中记录整个字符串长度的右括号

#### AB4 逆波兰表达式求值

描述
给定一个逆波兰表达式，求表达式的值。

数据范围：表达式长度满足 1 \le n \le 10^4   ，表达式中仅包含数字和 + ，- , * , / ，其中数字的大小满足 |val| \le 200 。

示例1

```
输入：["2","1","+","4","*"]
返回值：12
```

示例2

```
输入：["2","0","+"]
返回值：2
```

维持一个栈，存储操作数
遇到操作数则入栈
遇到运算符，则从弹出两个操作数进行计算，并将结果再存入栈中
注：这道题的除非运算，必须取整（四舍五入），即用int（b/a），而不能用b//a,双斜杠都是向下取整。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param tokens string字符串一维数组 
# @return int整型
#
class Solution:
    def evalRPN(self , tokens: List[str]) -> int:
        # write code here
        stack = [] # 存储操作数
        for i in tokens:
            if i in "+-*/":
                a = stack.pop()
                b = stack.pop()
                # 加减乘除
                if i == '+':
                    stack.append(b+a)
                elif i == '-':
                    stack.append(b-a)
                elif i == '*':
                    stack.append(b*a)
                else:
                    stack.append(int(b/a)) # 取整，四舍五入
            else:
                stack.append(int(i))
        return stack[0]
```

#### AB5 点击消除

描述
牛牛拿到了一个字符串。
他每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串"abbc"点击后可以生成"ac"。
但相同而不相邻、不相同的相邻字母都是不可以被消除的。
牛牛想把字符串变得尽可能短。他想知道，当他点击了足够多次之后，字符串的最终形态是什么？
输入描述：
一个字符串，仅由小写字母组成。（字符串长度不大于300000）
输出描述：
一个字符串，为“点击消除”后的最终形态。若最终的字符串为空串，则输出0。
示例1

```
输入：abbc
输出：ac
```

示例2

```
输入：abba
输出：0
```

示例3

```
输入：bbbbb
输出：b
```

思路：
step1：创建一个空栈；输入元素；
step2：遍历s，如果栈内元素为0，则直接添加；否则，如果栈内最后一个元素与i相等，则弹出该元素；否则直接添加；
step3：如果栈长度为0，打印0；否则，逐个打印；
代码如下：

```
stack = []
s = input()
for i in s:
    if len(stack) == 0:
        stack.append(i)
    else:
        if stack[-1] == i:
            stack.pop()
        else:
            stack.append(i)
if len(stack) == 0:
    print('0')
else:
    for i in stack:
        print(i,end = '')
```

#### AB6 表达式求值

描述
请写一个整数计算器，支持加减乘三种运算和括号。

数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内

要求：空间复杂度： O(n)O(n)，时间复杂度 O(n)O(n)

示例1

```
输入："1+2"
返回值：3
```

示例2

```
输入："(2*(3-4))*5"
返回值：-10
```

示例3

```
输入："3+2*3*4-1"
返回值：26
```

方法：栈 + 递归（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

对于上述两个要求，我们要考虑的是两点，一是处理运算优先级的问题，二是处理括号的问题。

处理优先级问题，那必定是乘号有着优先运算的权利，加号减号先一边看，我们甚至可以把减号看成加一个数的相反数，则这里只有乘法和加法，那我们优先处理乘法，遇到乘法，把前一个数和后一个数乘起来，遇到加法就把这些数字都暂时存起来，最后乘法处理完了，就剩余加法，把之前存起来的数字都相加就好了。

处理括号的问题，我们可以将括号中的部分看成一个新的表达式，即一个子问题，因此可以将新的表达式递归地求解，得到一个数字，再运算：

终止条件： 每次遇到左括号意味着进入括号子问题进行计算，那么遇到右括号代表这个递归结束。
返回值： 将括号内部的计算结果值返回。
本级任务： 遍历括号里面的字符，进行计算。
具体做法：

step 1：使用栈辅助处理优先级，默认符号为加号。
step 2：遍历字符串，遇到数字，则将连续的数字字符部分转化为int型数字。
step 3：遇到左括号，则将括号后的部分送入递归，处理子问题；遇到右括号代表已经到了这个子问题的结尾，结束继续遍历字符串，将子问题的加法部分相加为一个数字，返回。
step 4：当遇到符号的时候如果是+，得到的数字正常入栈，如果是-，则将其相反数入栈，如果是*，则将栈中内容弹出与后一个元素相乘再入栈。
step 5：最后将栈中剩余的所有元素，进行一次全部相加。
图示：

![50428EF40C2A491EE09E9D953F1B83C2](/Users/zzy/Downloads/Chrome下载/50428EF40C2A491EE09E9D953F1B83C2.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回表达式的值
# @param s string字符串 待计算的表达式
# @return int整型
#
class Solution:
    def solve(self , s: str) -> int:
        # write code here
        s = s.strip()
        stack = []
        res = 0
        num = 0
        sign = "+"
        index = 0
        while index < len(s):
            if s[index] == " ":
                index += 1
                continue
            # 遇到左括号
            if s[index] == "(":
                end = index + 1
                lens = 1
                while lens > 0:
                    if s[end] == "(":
                        lens += 1
                    if s[end] == ")":
                        lens -= 1
                    end += 1
                #将括号视为子问题进入递归
                num = self.solve(s[index + 1:end - 1])
                index = end - 1
                continue
            #字符数字转换成int数字
            if '0' <= s[index] <= '9':
                num = num * 10 + int(s[index])
            if not '0' <= s[index] <= '9' or index == len(s) - 1:
                #加
                if sign == '+':
                    stack.append(num)
                #减，加相反数
                elif sign == '-':
                    stack.append(-1 * num)
                #乘优先计算
                elif sign == '*':
                    stack.append(stack.pop() * num)
                num = 0
                sign = s[index]
            index += 1
        #栈中元素相加
        while stack:
            res += stack.pop()
        return res
```

### 队列

#### AB7 【模板】队列

描述
请你实现一个队列。
操作：
push x：将 x\x 加入队尾，保证 x\x 为 int 型整数。
pop：输出队首，并让队首出队
front：输出队首：队首不出队

输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。

输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若队列为空，则输出 "error“
否则按对应操作输出。
示例1

```
输入：
      6
      push 1
      pop
      front
      push 2
      push 3
      pop
输出：
      1
      error
      2
```

题解 | #【模板】队列#
两个栈来实现队列
核心思路是：栈（先进后出）弹出并压入另一个栈再弹出，完成先进先出

初始化两个栈，一个为输入栈s1，一个为输出栈s2，均使用list()实现
执行push，直接s1.append(x)
执行pop时：
先检查输出栈s2是否为空，不为空直接pop
再检查输入栈s1是否为空，为空则报错error
s1不为空则逐项pop到s2中，最后对s2执行pop
执行front时，和pop类似
先检查输出栈s2是否为空，不为空直接返回栈顶s2[-1]
再检查输入栈s1是否为空，为空则报错error
s1不为空则直接访问首个元素，即s1[0]

```
class Quene(object):
    def __init__(self):
        self.s1 = list() # 输入栈
        self.s2 = list() # 输出栈
    
    def push(self, x):
        self.s1.append(x)
        
    def pop(self):
        if len(self.s2):
            return self.s2.pop()
        if not len(self.s1):
            return 'error'
        for i in range(len(self.s1)):
            self.s2.append(self.s1.pop())
        return self.s2.pop()
    
    def front(self):
        if len(self.s2):
            return self.s2[-1]
        if not len(self.s1):
            return 'error'
        return self.s1[0]
    
    def check(self, d):
        if d == 'pop':
            print(self.pop())
        elif d == 'front':
            print(self.front())
        else:
            self.push(int(d.split()[-1]))

n = input()
tmp = Quene()
for _ in range(int(n)):
    data = input()
    tmp.check(data)
```

#### AB8 【模板】循环队列

描述
请你实现一个循环队列，该循环队列可利用的空间大小等于nn个int型变量的大小。
操作：
push x：将xx加入到循环队列尾端。若循环队列已满，输出"full"(不含引号)，否则不输出任何内容。保证xx为int型整数。
front：输出队首元素，队首不出队。若队列为空，输出"empty"(不含引号)。
pop：输出队首元素，且队首出队。若队列为空，输出"empty"(不含引号)。
输入描述：
第一行输入两个整数n,qn,q (1\le n,q \le 10^51≤n,q≤10 
5
 )，表示循环队列可利用的空间大小和操作次数。
接下来的qq行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。
输出描述：
按对应操作要求输出。
示例1

```
输入：
    3 10
    push 1
    push 2
    front
    push 3
    push 4
    pop
    pop
    pop
    front
    pop

输出：
    1
    full
    1
    2
    3
    empty
    empty
```

题解 | #【模板】循环队列#
基于普通的队列形式，增加队列长度的判断

```
class Cirque():
    def __init__(self):
        self.items = []
        
    def push(self, x):
        return self.items.append(x)
    
    def front(self):
        return self.items[0]
    
    def pop(self):
        return self.items.pop(0)
    
    def size(self):
        return len(self.items)
    
message = input() # 输入行信息
messagesplit = message.split()
n = int(messagesplit[0]) # 循环列表长度
q = int(messagesplit[1]) # 操作次数
s = Cirque()

for i in range(q):
    opo = input()
    oposplit = opo.split(" ")
    if oposplit[0] == 'push':
        if s.size() == n:
            print('full')
        else:
            s.push(oposplit[1])
    elif oposplit[0] == 'front':
        if s.size() == 0:
            print('empty')
        else:
            print(s.front())
    elif oposplit[0] == 'pop':
        if s.size() == 0:
            print('empty')
        else:
            print(s.pop())
    else:
        raise ValueError('无此操作')
```

### 链表

#### AB9 【模板】链表x

描述
请你实现一个链表。
操作：
insert x y：将y加入链表，插入在第一个值为x的结点之前。若链表中不存在值为x的结点，则插入在链表末尾。保证x,y为int型整数。
delete x：删除链表中第一个值为x的结点。若不存在值为x的结点，则不删除。
输入描述：
第一行输入一个整数nn (1≤n≤10^4^)，表示操作次数。
接下来的n行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。
输出描述：
输出一行，将链表中所有结点的值按顺序输出。若链表为空，输出"NULL"(不含引号)。
示例1

```
输入：
      5
      insert 0 1
      insert 0 3
      insert 1 2
      insert 3 4
      delete 4
输出：
      2 1 3
```

```
class linkedlist:
    def __init__(self):
        self.items = []
    
    def insert(self, x ,y):
        if x in self.items:
            loc = self.items.index(x)
            self.items.insert(loc, y)
        else:
            self.items.append(y)
            
    def delete(self, x):
        if x in self.items:
            loc = self.items.index(x)
            self.items.pop(loc)
            
    def size(self):
        return len(self.items)
    
    def traversal(self):
        for i in range(len(self.items)):
            print(self.items[i], end = " ")
            
s = linkedlist()
n = int(input())
for i in range(n):
    message = input()
    messagesplt = message.split(" ")
    if messagesplt[0] == "insert":
        a = messagesplt[1]
        b = messagesplt[2]
        s.insert(a, b)
    elif messagesplt[0] == "delete":
        a = messagesplt[1]
        s.delete(a)
    else:
        raise ValueError("无此操作")
if s.size() == 0:
    print("NULL")
else:
    s.traversal()
```

#### **AB10** **反转链表**

描述
给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0≤n≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n) 。

如当输入链表{1,2,3}时，
经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。
以上转换过程如下图所示：

![4A47A0DB6E60853DEDFCFDF08A5CA249](/Users/zzy/Downloads/Chrome下载/4A47A0DB6E60853DEDFCFDF08A5CA249.png)

示例1

```
输入：
      {1,2,3}
返回值：
      {3,2,1}	
```

示例2

```
输入：
      {}
返回值：
      {}
说明：
      空链表则输出空     
```

描述
这是一篇针对初学者的题解，共用2种方法解决。
知识点：单链表
难度：一星

题解
方法一：构造链表
如果此类型的题出现在笔试中，如果内存要求不高，可以采用如下方法：
可以先用一个vector将单链表的指针都存起来，然后再构造链表。
此方法简单易懂，代码好些。
###代码：

```

```

时间复杂度：O(n)
空间复杂度：O(n), 用了一个vector来存单链表

方法二：正规解法
但是面试的时候，上一种解法当然不行。此题想考察的是：如何调整链表指针，来达到反转链表的目的。
初始化：3个指针
1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向nullptr
2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向head
3）nex指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存
接下来，循环执行以下三个操作
1）nex = cur->next, 保存作用
2）cur->next = pre 未反转链表的第一个节点的下个指针指向已反转链表的最后一个节点
3）pre = cur， cur = nex; 指针后移，操作下一个未反转链表的第一个节点
循环条件，当然是cur != nullptr
循环结束后，cur当然为nullptr，所以返回pre，即为反转后的头结点=

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        # write code here
        pre = None
        phead = head
        while phead:
            temp = phead.next
            phead.next = pre
            pre = phead
            phead = temp
        return pre
```

#### AB11 合并两个排序的链表

描述
输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
数据范围： 0≤n≤1000，-1000≤节点值≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n)

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：

![09DD8C2662B96CE14928333F055C5580](/Users/zzy/Downloads/Chrome下载/09DD8C2662B96CE14928333F055C5580.png)

或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：

![8266E4BFEDA1BD42D8F9794EB4EA0A13](/Users/zzy/Downloads/Chrome下载/8266E4BFEDA1BD42D8F9794EB4EA0A13.png)

示例1

```
输入：
      {1,3,5},{2,4,6}
返回值：
      {1,2,3,4,5,6}
```

示例2

```
输入：
			{},{}
返回值：
			{}
```

示例3

```
输入：
			{-1,2,4},{1,3,4}
返回值：
			{-1,1,2,3,4,4}
```

非递归方法

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self , pHead1: ListNode, pHead2: ListNode) -> ListNode:
        # write code here
        dummy = cur = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val < pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 = pHead2.next
            cur = cur.next
        cur.next = pHead1 or pHead2
        return dummy.next
```

递归方法

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self , pHead1: ListNode, pHead2: ListNode) -> ListNode:
        # write code here
        if not pHead1 or not pHead2:
            return pHead1 or pHead2
        if pHead1.val < pHead2.val:
            pHead1.next = self.Merge(pHead1.next, pHead2)
            return pHead1
        else:
            pHead2.next = self.Merge(pHead1, pHead2.next)
            return pHead2
```

#### AB12 删除链表的节点

描述
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

1.此题对比原题有改动
2.题目保证链表中节点的值互不相同
3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

数据范围:
0<=链表节点值<=10000
0<=链表长度<=10000
示例1

```
输入：
      {2,5,1,9},5
返回值：
      {2,1,9}
说明：
给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -> 1 -> 9   
```

示例2

```
输入：
      {2,5,1,9},1
返回值：
      {2,5,9}
说明：
给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -> 5 -> 9   
```

题目的主要信息：
给定单链表的一个头，删除该链表指定节点
该链表所有元素不同
举一反三：
学习完本题的思路你可以解决如下题目：

JZ76. 删除链表中重复的结点

JZ6. 从尾到头打印链表

方法：迭代遍历（推荐使用）
思路：

既然是整个链表元素都不相同，我们要删除给定的一个元素，那我们首先肯定要找到这个元素，然后考虑删除它。

删除一个链表节点，肯定是断掉它的前一个节点指向它的指针，然后指向它的后一个节点，即越过了需要删除的这个节点。

```
//断开连接
pre.next = cur.next;
```

具体做法：

step 1：首先我们加入一个头部节点，方便于如果可能的话删除掉第一个元素。
step 2：准备两个指针遍历链表，一个指针指向当前要遍历的元素，另一个指针指向该元素的前序节点，便于获取它的指针。
step 3：遍历链表，找到目标节点，则断开连接，指向后一个。
step 4：返回时去掉我们加入的头节点。
图示：

![074232413F62F32D1B2134AF0B9ED494](/Users/zzy/Downloads/Chrome下载/074232413F62F32D1B2134AF0B9ED494.gif)

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param val int整型 
# @return ListNode类
#
class Solution:
    def deleteNode(self , head: ListNode, val: int) -> ListNode:
        # write code here
        res = ListNode(0)
        res.next = head
        #前序节点
        pre = res
        #当前节点
        cur = head
        #遍历链表
        while cur is not None:
            #找到目标节点
            if cur.val == val:
                #断开连接
                pre.next = cur.next
                break
            pre = cur
            cur = cur.next
            #返回去掉头节点
        return res.next
```

### 图论

#### AB13 【模板】拓扑排序

描述
给定一个包含n个点m条边的有向无环图，求出该图的拓扑序。若图的拓扑序不唯一，输出任意合法的拓扑序即可。若该图不能拓扑排序，输出−1。
输入描述：
第一行输入两个整数n,m ( 1≤n,m≤2⋅10^5^ )，表示点的个数和边的条数。
接下来的m行，每行输入两个整数u~i~,v~i~(1≤u,v≤n)，表示u~i~到,v~i~之间有一条有向边。
输出描述：
若图存在拓扑序，输出一行nn个整数，表示拓扑序。否则输出−1。
示例1

```
输入：
      5 4
      1 2
      2 3
      3 4
      4 5
输出：
      1 2 3 4 5
```

```
n, m = map(int, input().split())

graph = dict((str(i),[]) for i in range(1, n+1))
# print(graph)
# 边数
for i in range(m):
    j, k = input().split()
    graph[j].append(k)
# print(graph)

in_degree = dict((i,0) for i in graph)
# print(in_degree)
# 计算入度
for i in graph: # 遍历键 {'1': ['2'], '2': ['3'], '3': ['4'], '4': ['5'], '5': []}
    for j in graph[i]:
        in_degree[j] += 1
        
lis = [i for i in in_degree if in_degree[i] == 0] # 寻找入度为0
res = []

while lis:
    c = lis.pop()
    res.append(c)
    for i in graph[c]:
        in_degree[i] -=1
        if in_degree[i] == 0:
            lis.append(i)
            
if len(res) == n:
    print(" ".join(res))
else:
    print(-1)
```

#### AB14 最小生成树

描述
一个有 n 户人家的村庄，有 m 条路相互连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。

cost 为一个二维数组，每个元素是一个长度为 3 的一维数组 a ， a[0] 和 a[1] 表示村庄 a[0] 和村庄 a[1] 有一条路，修这条路的成本价格为 a[2] .

每户之间可能有多条道路连接，但不可能自己与自己相连

数据范围: 1≤n≤5×10^3^ ， 1 ≤m≤5×10^5^， 1≤a[2]≤10^4^

进阶： 时间复杂度 O(n+mlogm) ， 空间复杂度 O(n)
示例1

```
输入：
      3,3,[[1,3,3],[1,2,1],[2,3,1]]
返回值：
      2
```

示例2

```
输入：
      2,1,[[1,2,1]]
返回值：
			1
```

——首先具体连接图如图A所示，权值在图上的点与点之间的线上所标，刚开始找出最小的两点之间的权值为{V1，V3}，将V1与V3相连接形成图B，下面搜索与V3所连接的最小权值，据图发现，权值为4，所以连接{V3，V6}，形成图C，搜索与V6所连接的最小权值图为V4，将V6与V4相连接，形成图D，因为此时V4与周围的结点已经建立了连接了，所以向上返回到V6，V6与V4性质相同，向上返回到V3，寻找与V3最近且未连接的结点为V2，将V3与V2相连接，循环到V2，与V2最近的节点为V5，由此生成了一个最小值的树，最终将所有的值相加即可返回最近的值。这就是prim算法的具体步骤。

——在具体分析的过程中，首先将所有的数据添加到list链表当中，其次，一直通过循环来建立点与最小权值且可连接的边的点，建立完成之后，停止循环。所以其时间复杂度为O(N^2^)，因为构建了两个存储空间，一个用来存储最终的边，另一个用来存储最终的点，所以空间复杂度为O(N+M)。

——克鲁斯卡尔算法的核心是始终在图中寻找最短路径，如图A所示，第一条最短路径为1，连接点的双方为{V1，V3}，第二条最短路径的权值为2，连接点的双方为{V4，V6}，第三条最短路径为3，连接点的双方为{V2，V5}，第四条最短路径为4，连接点的双方为{V3，V6}，最后一条的权值为5，连接双方为{V2，V3}，最终形成和普里姆算法相同的图。

——克鲁斯卡尔算法的核心是通过对所有边权值大小进行排序，然后按照从大到小进行遍历，如果不能使现有的图成环的话就将边加入，然后将权值算入res中，一旦成环，就结束，在该算法中，有一种排序为对边进行排序，因为边数为M，所以对边进行排序的时间复杂度为O(MlogM)，总的时间复杂度为O(N+MlogM)，N为点，M为边，创建了一个p的内存空间，用来存储点和访问过的路径，所以其空间复杂度为O(N+M*2)。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回最小的花费代价使得这n户人家连接起来
# @param n int整型 n户人家的村庄
# @param m int整型 m条路
# @param cost int整型二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
# @return int整型
#

class Union:
    def __init__(self, n: int):
        self.parent = [0 for _ in range(n + 1)]
        self.rank = [0 for _ in range(n + 1)]
        self.count = n
        for i in range(n + 1):
            self.parent[i] = i
            self.rank[i] = 1
            
    def find(self, x):
        if x == self.parent[x]:
            return x
        return self.find(self.parent[x])
    
    def union(self, x, y):
        xi, yi = self.find(x), self.find(y)
        if xi == yi:
            return
        if self.rank[xi] > self.rank[yi]:
            self.parent[yi] = xi
            self.rank[xi] += self.rank[yi]
        else:
            self.parent[xi] = yi
            self.rank[yi] += self.rank[xi]
        self.count -= 1
        
    def connection(self, x ,y):
        xi ,yi = self.find(x), self.find(y)
        return xi == yi
        
    def count(self):
        return self.count          
    
class Solution:
    def miniSpanningTree(self , n: int, m: int, cost: List[List[int]]) -> int:
        # write code here
        union = Union(n)
        cost.sort(key = lambda x: x[2])
        res = 0
        for a, b, w in cost:
            if union.connection(a, b):
                continue
            res += w
            union.union(a, b)
        return res
```

#### AB15 【模板】单源最短路2

描述
给你一个无向图，图中包含 5000 个点 m 个边，任意两个点之间的距离是 w ，无重边或自环。请求出1号点到n号点的最短距离。

注意：图中可能存在孤立点，即存在点与任意点都没有边相连

如果1号点不能到达n号点，输出-1.


输入描述：

```

第一行两个整数n和m，表示图的点和边数。



接下来m行，每行三个整数u，v, w，表示u到v有一条无向边, 长度为w。



1≤n≤5000 1≤m≤50000 1≤w≤10000 
```

输出描述：

```
输出一行，表示1到n的最短路，如不存在，输出-1.
```

示例1

```
输入：
      4 4
      1 2 3
      2 4 7
      3 4 5
      3 1 3
输出：
      8
```

示例2

```
输入：
      4 3
      1 2 5
      2 3 3
      3 1 3
输出：
      -1
说明：
			1号点不能到4号点。
```

```
n, m = map(int, input().split())
graph = {}
for i in range(m):
    u, v, w = map(int, input().split())
    if u not in graph:
        graph[u] = {v: w}
    else:
        graph[u][v] = w
    if v not in graph:
        graph[v] = {u: w}
    else:
        graph[v][u] = w

def func():
    visit = {1}
    need_node = {(1,0): graph[1]}
    arri_node_val = {1: 0}
    
    while True:
        need_node1 = {}
        for u in need_node:
            for v in need_node[u]:
                if v not in arri_node_val:
                    arri_node_val[v] = u[1] + need_node[u][v]
                    need_node1[v, arri_node_val[v]] = graph[v]
                else:
                    if arri_node_val[v] > u[1] + need_node[u][v]:
                        arri_node_val[v] = u[1] + need_node[u][v]
                        need_node1[(v, arri_node_val[v])] = graph[v]
        if not need_node1:
            break
        else:
             need_node = need_node1
    if n not in arri_node_val:
        print(-1)
    else:
        print(arri_node_val[n])
        
func()
```

### 二叉树

#### AB16 实现二叉树先序，中序和后序遍历

描述
给定一棵二叉树，分别按照二叉树先序，中序和后序打印所有的节点。

数据范围：0≤n≤1000，树上每个节点的val值满足 0≤val≤100
要求：空间复杂度 O(n)，时间复杂度 O(n)

示例1

```
输入：
      {1,2,3}
返回值：
      [[1,2,3],[2,1,3],[2,3,1]] 
```

示例2

```
输入：
      {}
返回值：
      [[],[],[]]
```

备注：

```
n≤10**6
```

思路：
二叉树遍历没啥难度，按照常规操作递归遍历即可。
先序：根左右
中序：左根右
后序：左右根

代码：

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 the root of binary tree
# @return int整型二维数组
#
class Solution:
    def threeOrders(self , root: TreeNode) -> List[List[int]]:
        # write code here
        pre_order, in_order, post_order = [], [], []
        def find(root):
            if not root:
                return None
            pre_order.append(root.val) # 先序：根左右
            find(root.left)
            in_order.append(root.val) # 中序：左根右
            find(root.right)
            post_order.append(root.val) # 后序：左右根
        find(root)
        return [pre_order, in_order, post_order]
```

#### AB17 从中序与后序遍历序列构造二叉树

描述
给定一个二叉树的中序与后序遍历结果，请你根据两个序列构造符合这两个序列的二叉树。

数据范围：二叉树的节点数满足 1≤n≤1000  ，节点上的值满足∣val∣≤10^9^  ，保证节点的值各不相同

例如输入[2,1,4,3,5],[2,4,5,3,1]时，
根据中序遍历的结果[2,1,4,3,5]和后序遍历的结果[2,4,5,3,1]可构造出二叉树{1,2,3,#,#,4,5}，如下图所示：

![2F3F5D03085F56DA90CD8281C61709F9](/Users/zzy/Downloads/Chrome下载/2F3F5D03085F56DA90CD8281C61709F9.png)

示例1

```
输入：
      [1],[1]
返回值：
      {1}
```

示例2

```
输入：
      [2,1,4,3,5],[2,4,5,3,1]
返回值：
      {1,2,3,#,#,4,5}
```

题解 | #从中序与后序遍历序列构造二叉树#
发表于 2021-12-04 20:21:05
中序遍历: 左 -> 根 -> 右 后序遍历: 左 -> 右 -> 根 则后序遍历的最后一个节点为根节点,该节点在中序数组中的索引 idx 的左侧即为左子树[0:idx],右侧为右子树 [idx + 1:]，该索引代表了左子树的长度,在后序数组中左子树为[0:idx],右子树为[idx:-1],从上至下建立树

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param inorder int整型一维数组 中序遍历序列
# @param postorder int整型一维数组 后序遍历序列
# @return TreeNode类
#
class Solution:
    def buildTree(self , inorder: List[int], postorder: List[int]) -> TreeNode:
        # write code here
        if not inorder or not postorder:
            return None
        root = TreeNode(postorder[-1])
        idx = inorder.index(postorder[-1])
        root.left = self.buildTree(inorder[:idx], postorder[:idx])
        root.right = self.buildTree(inorder[idx + 1:], postorder[idx: -1])
        return root
```

### 堆

#### AB18 【模板】堆

描述
请你实现一个堆(大根堆)。
操作：
push x：将x加入堆。保证x为int型整数。不输出任何内容。
top：输出堆顶元素。若堆为空，输出"empty"(不含引号)。
pop：输出堆顶元素，且弹出堆顶。若堆为空，输出"empty"(不含引号)。
输入描述：
第一行输入一个整数n (1≤n≤10^5^)，表示操作次数。
接下来的n行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。
输出描述：
按对应操作要求输出。
示例1

```
输入：
      11
      push 1
      top
      push 3
      top
      push 2
      top
      pop
      pop
      pop
      top
      pop
输出：
      1
      3
      3
      3
      2
      1
      empty
      empty
```

题解 | #【模板】堆：一组数据实现最大堆 or 空数据逐步实现最大堆的步骤#
发表于 2022-03-21 10:58:37
最大堆的实现
目标：实现最大堆的构建以及调整->主要为添加一个元素或者弹出一个元素后的调整

```
class MyHeap(object):
    def __init__(self):
        # 定义一个大根堆
        self.heap = []
        self.length = 0
        
    # 对堆的调整：堆是一个完全二叉树，通过找到第一个非叶子节点的位置，并调整该节点与左右孩子的大小关系，使其实现最大堆的性值：根节点的值大于左右孩子的值
    def heapAdjust(self, root, size):
    
        # NoLeaf ->非叶子节点
        largest = root
        
        # 左孩子位置
        left = root * 2 + 1
        
        # 右孩子位置
        right = root * 2 + 2
        
        # 寻找出 这三个位置的最大值所在位置
        if left < size and self.heap[left] > self.heap[largest]:
            largest = left
        if right < size and self.heap[right] > self.heap[largest]:
            largest = right
            
        # 判断是否满足最大堆性质
        if largest != root:
            self.heap[largest],self.heap[root] = self.heap[root],self.heap[largest]
            
            # 根节点调整完后，继续查看 以子节点为根节点的子树是否满足最大堆性质
            self.heapAdjust(largest,self.length)

    def heap_push(self, val):
        self.heap.append(val)
        self.length += 1
        
        # 插入节点的父节点到根节点已经是有序的 只需要为新插入节点找到一个合适的位置
        newRoot = self.length - 1
        
        # 如果当前节点被换到堆顶，则调整结束：如果当前节点数据大于父节点数据，那么就进行交换
        while newRoot and (self.heap[newRoot] > self.heap[(newRoot - 1) // 2]):
            self.heap[newRoot],self.heap[(newRoot-1)//2] = self.heap[(newRoot - 1) //2],self.heap[newRoot]
            newRoot = (newRoot-1)//2
            
    def heap_pop(self):
        # 输出堆顶元素：也就是self.heap[0]
        if len(self.heap) == 0:
            print('empty')
        else:
            ans = self.heap[0]
            # 将堆顶元素调换到最后  对堆顶进行调整
            self.heap[0],self.heap[-1] = self.heap[-1],self.heap[0]
            # 弹出元素
            self.heap.pop()
            # 大小减一
            self.length -= 1
            self.heapAdjust(0, self.length)
            print(ans)

    # 获取堆顶元素
    def heap_top(self):
        if len(self.heap) == 0:
            print('empty')
        else:
            print(self.heap[0]) 
            
    # 对一组数据进行最大堆的构建        
    def heapConstruct(self):
        # 构建大根堆： 从第一个非叶子结点开始调整即可
        for root in range((self.length - 1 - 1) // 2, -1, -1):
            self.heapify(root, self.length)

if __name__ == '__main__':

    maxHeap = MyHeap()
    operNum = int(input())
    # 执行相应的命令
    for i in range(operNum):
        order = input().split()
        if order[0] == 'push':
            maxHeap.heap_push(int(order[1]))
        elif order[0] == 'top':
            maxHeap.heap_top()
        elif order[0] == 'pop':
            maxHeap.heap_pop()
```

## 02搜索

### bfs

#### AB19 【模板】单源最短路1

描述
给你一个无向图，图中包含 5000 个点 m 个边，任意两个点之间的距离是 1 ，无重边或自环。请求出1号点到n号点的最短距离。

注意：图中可能存在孤立点，即存在点与任意点都没有边相连

如果1号点不能到达n号点，输出-1.
输入描述：
第一行两个整数n和m，表示图的点和边数。
接下来m行，每行两个整数u，v，表示u到v有一条无向边。
1≤n≤5000
1 ≤m≤50000
输出描述：
输出一行，表示1到n的最短路，如不存在，输出-1.
示例1

```
输入：
      4 4
      1 2
      2 4
      3 4
      3 1
输出：
			2
```

示例2

```
输入：
      4 3
      1 2
      2 3
      3 1
输出：
			-1
说明：
1号点不能到4号点。
```

```
import sys
n, m = list(map(int, sys.stdin.readline().strip().split()))
graph = {}

for i in range(m):
    u, v = list(map(int, sys.stdin.readline().strip().split()))
    if u not in graph:
        graph[u] = [v]
    else: graph[u].append(v)
    if v not in graph: graph[v]=[u]
    else: graph[v].append(u)
result = {1:0}
nopass = {(1,0): graph[1]}
while True:
    temp = {}
    for u in nopass:
        for v in nopass[u]:
            if v not in result:
                result[v] = u[1] + 1
                temp[(v,result[v])] = graph[v]
            else:
                if result[v] > u[1] + 1:
                    result[v] = u[1] + 1
                    temp[(v,result[v])] = graph[v]
    if not temp: break
    else: nopass = temp
if n not in result: print(-1)
else: print(result[n])
```

#### AB20 走迷宫

描述
给定一个n×m的网格，在网格中每次在不超过边界的情况下可以选择向上、向下、向左、向右移动一格。网格中的一些格子上放置有障碍物，放有障碍物的格子不能到达。求从(x_s,y_s)到(x_t,y_t)(x_t,y_t)最少的移动次数。若不能到达，输出−1。
输入描述：
第一行输入两个整数n,m (1≤n,m≤1000)，表示网格大小。
第二行输入四个整数x_s,y_s,x_t,y_t表示起点和终点的坐标。
接下来的n行，每行输入一个长度为m的字符串。其中，第i行第j个字符表示第i行第j列的格子上的障碍物情况，若字符为'*'，则格子上有障碍物，若字符为'.'，则格子上没有障碍物。
保证起点不存在障碍物。
输出描述：
输出一行一个整数，表示从(x_s,y_s)到(x_t,y_t)最少的移动次数。

示例1

```
输入：
      5 5
      1 1 5 5
      .....
      ****.
      .....
      **.**
      .....
输出：
      12
```

示例2

```
输入：
      5 5
      1 1 5 5
      .....
      ****.
      .....
      *****
      .....
输出：
      -1
```

```
mn = list(map(int, input().split()))
n = mn[0]
m = mn[1]
site = list(map(int, input().split()))
mat = []
for i in range(n):
    ma = str(input())
    mat.append(list(ma))
move = 0
xs = site[0]-1
ys = site[1]-1
xt = site[2]-1
yt = site[3]-1

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]
def nearst():
    from queue import PriorityQueue
#     que = PriorityQueue()
    que = []
    # 起点加入队列
#     que.put((0, [xs,ys,0]))
    que.append([xs,ys,0])
    mat[xs][ys] = '*'
#     while not que.empty():
    while len(que) > 0:
#         sit = que.get()[1]
        sit = que.pop(0)
        for i in range(4):
            xi = sit[0] + dx[i]
            yi = sit[1] + dy[i]
            if xi >=0 and xi < n and yi >= 0 and yi < m and mat[xi][yi] == '.':
                if xi == xt and yi == yt:
                    return sit[2]+1
                else:
                    mat[xi][yi] = '*'
                    que.append([xi, yi, sit[2]+1])
#                     que.put((sit[2]+1, [xi, yi, sit[2]+1]))
    return -1
print(nearst())
```

### dfs

#### AB21 N皇后问题

描述
N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，
要求：任何两个皇后不同行，不同列也不在同一条斜线上，
求给一个整数 n ，返回 n 皇后的摆法数。

数据范围: 1≤n≤9
要求：空间复杂度O(1) ，时间复杂度 O(n!)

例如当输入4时，对应的返回值为2，
对应的两种四皇后摆位如下图所示：

示例1

```
输入：
      1
返回值：
      1
```

示例2

```
输入：
      8
返回值：
			92
```

方法：递归（推荐使用）
知识点：递归与回溯

递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。因此递归过程，最重要的就是查看能不能讲原本的问题分解为更小的子问题，这是使用递归的关键。

如果是线型递归，子问题直接回到父问题不需要回溯，但是如果是树型递归，父问题有很多分支，我需要从子问题回到父问题，进入另一个子问题。因此回溯是指在递归过程中，从某一分支的子问题回到父问题进入父问题的另一子问题分支，因为有时候进入第一个子问题的时候修改过一些变量，因此回溯的时候会要求改回父问题时的样子才能进入第二子问题分支。

n个皇后，不同行不同列，那么肯定棋盘每行都会有一个皇后，每列都会有一个皇后。如果我们确定了第一个皇后的行号与列号，则相当于接下来在n−1行中查找n−1个皇后，这就是一个子问题，因此使用递归：

终止条件： 当最后一行都被选择了位置，说明n个皇后位置齐了，增加一种方案数返回。
返回值： 每一级要将选中的位置及方案数返回。
本级任务： 每一级其实就是在该行选择一列作为该行皇后的位置，遍历所有的列选择一个符合条件的位置加入数组，然后进入下一级。
具体做法：

step 1：对于第一行，皇后可能出现在该行的任意一列，我们用一个数组pos记录皇后出现的位置，下标为行号，元素值为列号。
step 2：如果皇后出现在第一列，那么第一行的皇后位置就确定了，接下来递归地在剩余的n−1行中找n−1个皇后的位置。
step 3：每个子问题检查是否符合条件，我们可以对比所有已经记录的行，对其记录的列号查看与当前行列号的关系：即是否同行、同列或是同一对角线。
图示：

![CAAF9B6E5081EEAD4FFF714ED2F8CBA5](/Users/zzy/Downloads/Chrome下载/CAAF9B6E5081EEAD4FFF714ED2F8CBA5.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 the n
# @return int整型
#
class Solution:
    #判断皇后是否符合条件
    def isValid(self, pos: List[int], row:int, col:int): 
        #遍历所有已经记录的行
        for i in range(row): 
            #不能同行同列同一斜线
            if row == i or col == pos[i] or abs(row - i) == abs(col - pos[i]): 
                return False
        return True
    
    #递归查找皇后种类
    def recursion(self, n:int, row:int, pos:List[int], res:int): 
        #完成全部行都选择了位置
        if row == n: 
            res += 1
            return int(res)
        #遍历所有列
        for i in range(n): 
            #检查该位置是否符合条件
            if self.isValid(pos, row, i):  
                #加入位置
                pos[row] = i 
                #递归继续查找
                res = self.recursion(n, row + 1, pos, res) 
        return res

    def Nqueen(self , n: int) -> int:
        res = 0
        #下标为行号，元素为列号，记录皇后位置
        pos = [0] * n 
        #递归
        result = self.recursion(n, 0, pos, res) 
        return result
```

复杂度分析：

时间复杂度：O(n*n!)，isValid函数每次检查复杂度为O(n)，递归过程相当于对长度为n的数组求全排列，复杂度为O(n!)
空间复杂度：O(n)，辅助数组和栈空间最大为O(n)

#### AB22 岛屿数量

描述
给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。
岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。
例如：
输入
[
[1,1,0,0,0],
[0,1,0,1,1],
[0,0,0,1,1],
[0,0,0,0,0],
[0,0,1,1,1]
]
对应的输出为3
(注：存储的01数据其实是字符'0','1')

示例1

```
输入：
      [[1,1,0,0,0],[0,1,0,1,1],[0,0,0,1,1],[0,0,0,0,0],[0,0,1,1,1]]
返回值：
      3
```

示例2

```
输入：
      [[0]]
返回值：
      0
```

示例3

```
输入：
			[[1,1],[1,1]]
返回值：
			1
```

方法一：dfs（推荐使用）
知识点：深度优先搜索（dfs） 深度优先搜索一般用于树或者图的遍历，其他有分支的（如二维矩阵）也适用。它的原理是从初始点开始，一直沿着同一个分支遍历，直到该分支结束，然后回溯到上一级继续沿着一个分支走到底，如此往复，直到所有的节点都有被访问到。

思路：

矩阵中多处聚集着1，要想统计1聚集的堆数而不重复统计，那我们可以考虑每次找到一堆相邻的1，就将其全部改成0，而将所有相邻的1改成0的步骤又可以使用深度优先搜索（dfs）：当我们遇到矩阵的某个元素为1时，首先将其置为了0，然后查看与它相邻的上下左右四个方向，如果这四个方向任意相邻元素为1，则进入该元素，进入该元素之后我们发现又回到了刚刚的子问题，又是把这一片相邻区域的1全部置为0，因此可以用递归实现。

```
//后续四个方向遍历
if(i - 1 >= 0 && grid[i - 1][j] == '1') 
    dfs(grid, i - 1, j);
if(i + 1 < n && grid[i + 1][j] == '1') 
    dfs(grid, i + 1,j);
if(j - 1 >= 0 && grid[i][j - 1] == '1') 
    dfs(grid, i, j - 1);
if(j + 1 < m && grid[i][j + 1] == '1') 
    dfs(grid, i, j + 1)
```

终止条件： 进入某个元素修改其值为0后，遍历四个方向发现周围都没有1，那就不用继续递归，返回即可，或者递归到矩阵边界也同样可以结束。
返回值： 每一级的子问题就是把修改后的矩阵返回，因为其是函数引用，也不用管。
本级任务： 对于每一级任务就是将该位置的元素置为0，然后查询与之相邻的四个方向，看看能不能进入子问题。
具体做法：

step 1：优先判断空矩阵等情况。
step 2：从上到下从左到右遍历矩阵每一个位置的元素，如果该元素值为1，统计岛屿数量。
step 3：接着将该位置的1改为0，然后使用dfs判断四个方向是否为1，分别进入4个分支继续修改。
图示：

![CAAF9B6E5081EEAD4FFF714ED2F8CBA5](/Users/zzy/Downloads/Chrome下载/CAAF9B6E5081EEAD4FFF714ED2F8CBA5.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 判断岛屿数量
# @param grid char字符型二维数组 
# @return int整型
#
class Solution:
    #深度优先遍历与i，j相邻的所有1
    def dfs(self, grid:List[List[chr]], i:int, j:int) : 
        n = len(grid)
        m = len(grid[0])
        #置为0
        grid[i][j] = '0' 
        #后续四个方向遍历
        if i - 1 >= 0 and grid[i - 1][j] == '1':
            self.dfs(grid, i - 1, j)
        if i + 1 < n and grid[i + 1][j] == '1':
            self.dfs(grid, i + 1, j)
        if j - 1 >= 0 and grid[i][j - 1] == '1':
            self.dfs(grid, i, j - 1)
        if j + 1 < m and grid[i][j + 1] == '1':
            self.dfs(grid, i, j + 1)
            
    def solve(self , grid: List[List[str]]) -> int:
        n = len(grid)
        #空矩阵的情况
        if  n == 0: 
            return 0
        m = len(grid[0])
        #记录岛屿数
        count = 0 
        #遍历矩阵
        for i in range(n): 
            for j in range(m):
                #遍历到1的情况
                if grid[i][j] == '1': 
                    #计数
                    count += 1 
                    #将与这个1相邻的所有1置为0
                    self.dfs(grid, i, j) 
        return count
```

复杂度分析：

时间复杂度：O(nm)，其中m、n为矩阵的长和宽，需要遍历整个矩阵，每次dfs搜索需要经过每个值为1的元素，但是最坏情况下也只是将整个矩阵变成0，因此相当于最坏遍历矩阵2次
空间复杂度：O(nm)，最坏情况下整个矩阵都是1，递归栈深度为mn

#### AB23 kotori和素因子

描述
kotori拿到了一些正整数。她决定从每个正整数取出一个素因子。但是，kotori有强迫症，她不允许两个不同的正整数取出相同的素因子。

她想知道，最终所有取出的数的和的最小值是多少？

注：若a%k==0，则称k是a的因子。若一个数有且仅有两个因子，则称其是素数。显然1只有一个因子，不是素数。




输入描述：
第一行一个正整数n，代表kotori拿到正整数的个数。

第二行共有n个数ai，表示每个正整数的值。

保证不存在两个相等的正整数。

1<=n<=10

2<=ai<=1000
输出描述：
一个正整数，代表取出的素因子之和的最小值。若不存在合法的取法，则输出-1。

示例1

```
输入：
      4
      12 15 28 22
输出：
      17
说明：
分别取3，5，7，2，可保证取出的数之和最小 
```

示例2

```
输入：
      5
      4 5 6 7 8
输出：
      -1
```

备注：

```
1<=n<=10

2<=ai<=1000
```

```
n=int(input())
a=[int(i) for i in input().split()]
visited=[False]*2000
def f(x):
    for i in range(2,x):
        if x%i==0:
            return False
    return True
mi=9999999
def dfs(x,s):
    global visited,mi,n
    #print(x,s)
    if x==n:
        mi=min(mi,s)
        return
    for i in range(2,a[x]+1):
        if a[x]%i==0 and not visited[i] and f(i):
            visited[i]=True
            dfs(x+1,s+i)
            visited[i]=False
dfs(0,0)
if mi==9999999:
    mi=-1
print(mi)
```

## 03基础算法

### 查找

#### AB24 二分查找-I

描述
请实现无重复数字的升序数组的二分查找

给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1

数据范围：0≤len(nums)≤2×10^5^， 数组中任意值满足∣val∣≤10^9^

进阶：时间复杂度O(logn) ，空间复杂度O(1)

示例1

```
输入：
			[-1,0,3,4,6,10,13,14],13
返回值：
			6
说明：13 出现在nums中并且下标为 6     
```

示例2

```
输入：
      [],3
返回值：
      -1
说明：nums为空，返回-1     
```

示例3

```
输入：
			[-1,0,3,4,6,10,13,14],2
返回值：
			-1
说明：2 不存在nums中因此返回 -1    
```

 方法：二分法（推荐使用）
知识点：分治

分治即“分而治之”，“分”指的是将一个大而复杂的问题划分成多个性质相同但是规模更小的子问题，子问题继续按照这样划分，直到问题可以被轻易解决；“治”指的是将子问题单独进行处理。经过分治后的子问题，需要将解进行合并才能得到原问题的解，因此整个分治过程经常用递归来实现。

思路：

本来我们可以遍历数组直接查找，每次检查当前元素是不是要找的值。

```
for(int i = 0; i < nums.length; i++)
    if(nums[i] == target)
        return i;
```

但是这样这个有序的数组我们就没有完全利用起来。我们想想，若是目标值比较小，肯定在前半区间，若是目标值比较大，肯定在后半区间，怎么评价大小？我们可以用中点值作为一个标杆，将整个数组分为两个区间，目标值与中点值比较就能知道它会在哪个区间，这就是分治的思维。

具体做法：

step 1：从数组首尾开始，每次取中点值。
step 2：如果中间值等于目标即找到了，可返回下标，如果中点值大于目标，说明中点以后的都大于目标，因此目标在中点左半区间，如果中点值小于目标，则相反。
step 3：根据比较进入对应的区间，直到区间左右端相遇，意味着没有找到。
图示：

![BD9B94E79756B5639D9B9F3F09A66631](/Users/zzy/Downloads/Chrome下载/BD9B94E79756B5639D9B9F3F09A66631.gif)

```
class Solution:
    def search(self , nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        # 从数组首尾开始，直到二者相遇
        while l <= r :
            # 每次检查中点的值 
            m = int((l+r)/2) 
            if nums[m] == target:
                return m
            # 进入左的区间
            if nums[m] > target: 
                r = m - 1
            # 进入右区间
            else: 
                l = m + 1
        # 未找到
        return -1 
```

复杂度分析：

时间复杂度：O(log_2n)，对长度为n的数组进行二分，最坏情况就是取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### 枚举

#### AB25 ranko的手表

描述
ranko 的手表坏了，正常应该显示 xx:xx 的形式（4 个数字），比如下午 1 点半应该显示 13:30 ，但现在经常会有一些数字有概率无法显示。
ranko 在  t_1时刻看了下时间，过了一段时间在 t_2时刻看了下时间。她想知道， t_1和 t_2这两个时刻之间相距的时间的最大值和最小值是多少？
保证 t_1在 t_2之前（且 t_1和 t_2不等）。t_1和 t_2在同一天的 00:00 到 23:59 之间。
输入描述：
两行输入两个时间，为 xx:xx 的形式。其中 xx 为数字或者字符 '?' ，问号代表这个数字没有显示。
保证输入是合法的。
输出描述：
一行输出两个整数，分别代表 t_1和 t_2相距时间的最小值和最大值（单位分钟）。

示例1

```
输入：
      18:0?
      2?:1?
输出：
      121 319
说明：
      相距最小的时间为 18:09 到 20:10 ，相距121分钟。
      相距最大的时间为 18:00 到 23:19 ，相距319分钟。
```

```
采用枚举的方式，将一天的时间转换为0 - 60 * 24 分钟并进行遍历，每个遍历值记为i
创建两个列表，分别存储两个输入时间的可能分钟数
分别判断遍历值i能否满足两个输入值的格式，若满足，则将i添加到对应的列表中
```

```
s1 = input()
s2 = input()

# 创建两个空列表存储可能的时间
list1 = []
list2 = []

# 遍历0 - 60 * 24 分钟
for i in range(0, 60 * 24):

    hour = int(i //60) # 获取小时
    minute = int(i % 60) # 获取分钟
    
    # 十位数等于"?"，或者与hour(mimute) // 10相等时，遍历值可取
    # 十位数等于"?"，或者与hour(mimute) % 10相等时，遍历值可取
    if s1[0] == '?' or int(s1[0]) == hour // 10:
        if s1[1] == '?' or int(s1[1]) == hour % 10:
            if s1[3] == '?' or int(s1[3]) == minute // 10:
                if s1[4] == '?' or int(s1[4]) == minute % 10:
                    list1.append(i)
    
    if s2[0] == '?' or int(s2[0]) == hour // 10:
        if s2[1] == '?' or int(s2[1]) == hour % 10:
            if s2[3] == '?' or int(s2[3]) == minute // 10:
                if s2[4] == '?' or int(s2[4]) == minute % 10:
                    list2.append(i)

# 初始化最大值、最小值
mintime = 60 * 24
maxtime = 0
# 遍历两个列表，取可能的组合，计算最大值、最小值
for i in range(len(list1)):
    for j in range(len(list2)):
        if list1[i] < list2[j]:
            mintime = min(mintime, list2[j] - list1[i])
            maxtime = max(maxtime, list2[j] - list1[i])

print(mintime, maxtime)
```

### 递归

#### AB26 汉诺塔问题

描述
我们有由底至上为从大到小放置的 n 个圆盘，和三个柱子（分别为左/中/右即left/mid/right），开始时所有圆盘都放在左边的柱子上，按照汉诺塔游戏的要求我们要把所有的圆盘都移到右边的柱子上，要求一次只能移动一个圆盘，而且大的圆盘不可以放到小的上面。

请实现一个函数打印最优移动轨迹。

给定一个 `int n` ，表示有 n 个圆盘。请返回一个 `string` 数组，其中的元素依次为每次移动的描述。描述格式为： `move from [left/mid/right] to [left/mid/right]`。

数据范围：1≤n≤16
要求：时间复杂度 O(3^n)， 空间复杂度 O(3^n)

示例1

```
输入：
			2
返回值：
			["move from left to mid","move from left to right","move from mid to right"]
```

方法一
递归
汉诺塔问题的解决方案可以分为3步：
1、把n-1个盘子从left 借助 right，搬到mid柱子上；
2、把剩下最大的那一个盘子从left搬到right柱子上；
3、把n-1个盘子从mid 借助 left，搬到right柱子上。
示意图如下：

![CED30BBF7CF0F4B079B4AFB7B7F2BEA7](/Users/zzy/Downloads/Chrome下载/CED30BBF7CF0F4B079B4AFB7B7F2BEA7.png)

至于如何把n-1个盘子搬到另一个柱子上，同样参照上面的3步，不过此时柱子扮演的left，mid，right角色已经改变；对于n-2，n-3等等以此类推。
具体代码如下：

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return string字符串一维数组
#
class Solution:
    
    def getSolution(self , n ):
        # write code here
        s = []
        rst = self.get_rst(n, s, 'left', 'mid', 'right')
        return rst
    def get_rst(self, n ,s, left, mid, right):
        if n == 1:
            s.append("move from " + left + " to " + right)
            return s
        else:
            self.get_rst(n-1, s, left, right, mid)   # 将n-1个盘子从x借助z移动到y上
            s.append("move from " + left + " to " + right)    # 将第n个盘子从x移动到z上
            self.get_rst(n-1, s, mid, left, right)    # 将n-1个盘子从y借助x移动到x上
            return s
```

时间复杂度：O(2^N)。假设把n个盘子搬动耗时T(n)，则有T(n)=2T(n-1)+1，从而[T(n)+1]/[T(n-1)+1]=2，对该等比数列求解即可。
空间复杂度：O(N)。递归栈的深度。

#### AB27 循环汉诺塔

描述
Eli最近迷上了汉诺塔。她玩了传统汉诺塔后突发奇想，发明了一种新的汉诺塔玩法。
有A、B、C三个柱子顺时针放置，移动的次序为A仅可以到B，B仅可以到C、C仅可以到A。即只可顺时针移动，不可逆时针移动。当然，汉诺塔的普适规则是适用的：每次移动后，大金片必须在小金片的下面。
现在A柱子上有n 个金片。Eli想知道，她把这些全部移动到B或C，分别要多少次操作？
输入描述：
一个正整数n\n 。(n<10^7)
输出描述：
两个整数，分别代表A移到B和A移到C的最少操作数。由于该数可能过大，你需要对1000000007取模。
示例1

```
输入：
      2
输出：
      5 7
说明：
      A移到B的5步：A->B  B->C  A->B  C->A  A->B
      A移到C的7步：A->B  B->C  A->B  C->A  B->C  A->B  B->C
```

```
动态规划
确定状态，记所有盘子移动从AAA移动到BBB状态为0，从AAA移动到CCC状态为1;

第nnn步的状态为dp[n][0]dp[n][0]dp[n][0]、dp[n][1]dp[n][1]dp[n][1]，dp[n][0]dp[n][0]dp[n][0] 表示为所有盘子移动到BBB所需要的次数，dp[n][1]dp[n][1]dp[n][1] 表示为所有盘子移动到CCC所需要的次数。

第nnn个盘子可以移动到BBB时只需要移动1次，前n−1n-1n−1个盘子一定全部都在CCC上, 并且接下来要将CCC上的所有盘子移动到BBB上，此时所需要移动次数等同于将前n−1n-1n−1个盘子从AAA移动到CCC上，因此此时的状态转移为:
dp[n][0]=1+dp[n−1][1]∗2dp[n][0] = 1 + dp[n-1][1] * 2dp[n][0]=1+dp[n−1][1]∗2

由此类推，所有盘子移动到CCC时，一定是第nnn个盘子先移动到BBB之后，再移动到CCC,即需要222步,而第nnn个盘子移动到BBB时，前n−1n-1n−1个盘子一定全部都在CCC上,移动次数为dp[n−1][1]dp[n-1][1]dp[n−1][1],且第nnn个盘子要移动到CCC时，前n−1n-1n−1个盘子一定要移动到AAA上，此时移动步数等价于将n−1n-1n−1个盘子从AAA移动到BBB的步数，即dp[n−1][0]dp[n-1][0]dp[n−1][0],当第nnn个盘子移动到CCC之后，又要将前n−1n-1n−1个盘子从AAA移动到CCC上。 因此此时的状态转移为：
dp[n][1]=1+dp[n−1][1]+1+dp[n−1][0]+dp[n−1][1]dp[n][1] = 1 + dp[n-1][1] + 1 + dp[n-1][0] + dp[n-1][1]dp[n][1]=1+dp[n−1][1]+1+dp[n−1][0]+dp[n−1][1]
即:
dp[n][0]=1+dp[n−1][1]∗2dp[n][0] = 1 + dp[n-1][1] * 2dp[n][0]=1+dp[n−1][1]∗2
dp[n][1]=2+dp[n−1][1]∗2+dp[n−1][0]dp[n][1] = 2 + dp[n-1][1] * 2 + dp[n-1][0]dp[n][1]=2+dp[n−1][1]∗2+dp[n−1][0]
```

```
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9+7;

ll dp[10000005][2];
int n;
int main(){
    cin>>n;
    
    dp[1][0] = 1;dp[2][0] = 5;
    dp[1][1] = 2;dp[2][1] = 7;
    
    for(int i = 3; i <= n; ++i){
        dp[i][0] = (1 + dp[i-1][1] * 2) % mod;
        dp[i][1] = (2 + dp[i-1][1] * 2 + dp[i-1][0]) % mod;
    }
    cout<<dp[n][0]<<' '<<dp[n][1]<<endl;
    return 0;
    
}
```

### 分治

#### AB28 快速幂

```
描述
请你计算 a^b mod p的值。
一共有 q 次询问。
输入描述：
第一行输入一个正整数 q ，代表询问次数。
接下来每行输入三个正整数 a,b,p代表一次询问。
数据范围：
1≤q≤10^5
1≤a,b,p≤10^7

输出描述：
对于每次询问，输出一个整数，代表 a^b mod p的值。
```

示例1

```
输入：
      2
      2 2 6
      3 4 10
输出：
      4
      1
```

题解 | #快速幂#
发表于 2022-04-25 12:08:28
若采用循环直接实现幂指数计算时间复杂度为O(n)
使用快速幂的方式，即计算的幂指数的指数部分每次减半，底数变为平方。通过对折的方式，减少指数部分，从而减少循环的次数。

```
（对指数奇偶性进行判断）当指数大于零的时候，对2取余数，余数为1的时候，此时计算的结果res乘一次底数，并将结果对p取余。
指数对2取整（变为原来的一半），底数取平方并对p取余数。
当指数<=0，跳出循环。
```

tips:计算中对p取余数，防止数值过大，造成内存溢出。

```
# @param q 询问次数
# @param a 底数
# @param b 指数
# @param p 除数
# @return res 幂指数对p取余数 

def fast_power(base, power, p):
    res = 1
    while power > 0:
        if power % 2 == 1:
            res = res * base % p
        power = power // 2
        base = base * base % p
    return res % p
q = int(input())

for i in range(q):
    s = input()
    splt = s.split()
    a = int(splt[0])
    b = int(splt[1])
    p = int(splt[2])
    ans = fast_power(a, b, p)
    print(ans)
```

#### AB29 快速乘

```
描述
请你计算 a∗b mod p 的值。要求只能使用加法和取模运算，且计算过程中的值不能超过 2*10^7。
一共有 q 次询问。
输入描述：
第一行输入一个正整数 q ，代表询问次数。
接下来每行输入三个正整数 a,b,p ，代表一次询问。
数据范围：
1≤q≤10^5

1≤a,b,p≤10^7
 
输出描述：
对于每次询问，输出一个整数，代表 a∗b mod p 的值。
示例1
输入：
      2
      2 2 6
      3 4 10
输出：
      4
      2
```

```
ask_num = int(input())
# print(ask_num)
para_list_list = []
for i in range(0, ask_num):
    para_list = input().split(' ')
    # print(para_list)
    para_list_list.append(para_list)


def calculate_multiple_mod(a, b, p):
    if b == 1:
        return a % p
    if b % 2 == 1:
        return (2 * calculate_multiple_mod(a, b // 2, p) + a % p) % p
    if b % 2 == 0:
        return (2 * calculate_multiple_mod(a, b // 2, p)) % p


for i in range(0, ask_num):
    a_int = int(para_list_list[i][0])
    b_int = int(para_list_list[i][1])
    p_int = int(para_list_list[i][2])
    print(calculate_multiple_mod(a_int, b_int, p_int))
```

