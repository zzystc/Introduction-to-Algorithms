# [算法入门](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=308)

## 01数据结构

### 栈

#### AB1【模板】栈

描述
请你实现一个栈。
操作：
push x：将 加x\x 入栈，保证 x\x 为 int 型整数。
pop：输出栈顶，并让栈顶出栈
top：输出栈顶，栈顶不出栈
输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。

输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若栈为空，则输出 "error“
否则按对应操作输出。

示例1

```
输入：
6
push 1
pop
top
push 2
push 3
pop

输出：
1
error
3
```

思路
step1：首先初始化栈（第1至13行）
step2：创建栈s，同时输入执行命令次数，按次数执行指令；
step3：按照题目要求，满足要求；
代码如下：

```
class Stack():
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def push(self,item):
        self.items.append(item)
    def pop(self):
        return self.items.pop()
    def peek(self):
        return self.items[len(self.items) - 1]
    def size(self):
        return self.items[len(self.items)]
    
s = Stack()
num = int(input())
for i in range(num):
    a=input()
    if a[0:4] == 'push':
        b = a.split(' ')
        s.push(int(b[1]))
    if a == 'pop':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
            s.pop()
    if a == 'top':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
```

#### AB2 栈的压入、弹出序列

描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
1. 0<=pushV.length == popV.length <=1000
2. -1000<=pushV[i]<=1000
3. pushV 的所有数字均不相同
示例1

示例1

```
输入：[1,2,3,4,5],[4,5,3,2,1]
返回值：true
说明：可以通过push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true   
```

示例2

```
输入：[1,2,3,4,5],[4,3,5,1,2]
返回值：false
说明：由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false      
```

方法一：辅助栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

题目要我们判断两个序列是否符合入栈出栈的次序，我们就可以用一个栈来模拟。对于入栈序列，只要栈为空，序列肯定要依次入栈。那什么时候出来呢？自然是遇到一个元素等于当前的出栈序列的元素，那我们就放弃入栈，让它先出来。

```
//入栈：栈为空或者栈顶不等于出栈数组
while(j < n && (s.isEmpty() || s.peek() != popA[i])){
    s.push(pushA[j]);
    j++;
}
```

具体做法：

step 1：准备一个辅助栈，两个下标分别访问两个序列。
step 2：辅助栈为空或者栈顶不等于出栈数组当前元素，就持续将入栈数组加入栈中。
step 3：栈顶等于出栈数组当前元素就出栈。
step 4：当入栈数组访问完，出栈数组无法依次弹出，就是不匹配的，否则两个序列都访问完就是匹配的。
图示：

![7F25B229A4900F6E066BE03E92B0492E](/Users/zzy/Downloads/Chrome下载/7F25B229A4900F6E066BE03E92B0492E.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        n = len(pushV)
        #辅助栈
        s = []
        #遍历入栈的下标
        j = 0
        #遍历出栈的数组
        for i in range(n):
            #入栈：栈为空或者栈顶不等于出栈数组
            while j < n and (len(s) == 0 or s[-1] != popV[i]):
                s.append(pushV[j])
                j += 1
            #栈顶等于出栈数组
            if s[-1] == popV[i]:
                s.pop()
            #不匹配序列
            else:
                return False
        return True
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏情况下需要遍历两个数组各一次
空间复杂度：O(n)O(n)O(n)，辅助栈空间最大为一个数组的长度

方法二：原地栈（扩展思路）
思路：

方法一我们使用了一个辅助栈来模拟，但是数组本来就很类似栈啊，用下标表示栈顶。在方法一种push数组前半部分入栈了，就没用了，这部分空间我们就可以用来当成栈。原理还是同方法一一样，只是这时我们遍历push数组的时候，用下标n表示栈空间，n的位置就是栈顶元素。

具体做法：

step 1：用下标n表示栈空间，用j表示出栈序列的下标。
step 2：遍历每一个待入栈的元素，加入栈顶，即push数组中n的位置，同时增加栈空间的大小，即n的大小。
step 3：当栈不为空即栈顶n大于等于0，且栈顶等于当前出栈序列，就出栈，同时缩小栈的空间，即减小n。
step 4：最后若是栈空间大小n为0，代表全部出栈完成，否则不匹配。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        #表示栈空间的大小，初始化为0
        n = 0
        #出栈序列的下标
        j = 0
        #对于每个待入栈的元素
        for num in pushV:
            #加入栈顶
            pushV[n] = num
            #当栈不为空且栈顶等于当前出栈序列
            while n >= 0 and pushV[n] == popV[j]:
                #出栈，缩小栈空间
                j += 1
                n -= 1
            n += 1
        #最后的栈是否为空
        return True if n == 0 else False
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏还是遍历两个数组
空间复杂度：O(1)O(1)O(1)，常数级变量，无额外辅助空间

#### AB3 有效括号序列

描述
给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

数据范围：字符串长度 0\le n \le 100000≤n≤10000
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
示例1

```
输入："()[]{}"
返回值：true
```

示例2

```
输入："[]"
返回值：true
```

示例3

```
输入："([)]"
返回值：false
```

方法：栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

括号的匹配规则应该符合先进后出原理：最外层的括号即最早出现的左括号，也对应最晚出现的右括号，即先进后出，因此可以使用同样先进后出的栈：遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。

具体做法：

step 1：创建辅助栈，遍历字符串。
step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。
step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。
step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。
step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。
图示：

![4760A3E42ACB7E73D162BE2CD8C2E2C9](/Users/zzy/Downloads/Chrome下载/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return bool布尔型
#
class Solution:
    def isValid(self , s: str) -> bool:
        # write code here
        #辅助栈
        st = []
        #遍历字符串
        for i, char in enumerate(s):
            #遇到左小括号
            if char == '(':
                #期待遇到右小括号
                st.append(')')
            #遇到左中括号
            elif char == '[':
                #期待遇到右中括号
                st.append(']')
            #遇到左大括号
            elif char == '{':
                #期待遇到右大括号
                st.append('}')
            #必须有左括号的情况下才能遇到右括号
            elif (len(st) == 0):
                return False
            #右括号匹配则弹出
            elif (st[-1] == char):
                st.pop()
        #栈中是否还有元素
        return len(st) == 0
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为字符串长度，遍历整个字符串
空间复杂度：O(n)O(n)O(n)，最坏情况下栈空间中记录整个字符串长度的右括号

#### AB4 逆波兰表达式求值

描述
给定一个逆波兰表达式，求表达式的值。

数据范围：表达式长度满足 1 \le n \le 10^4   ，表达式中仅包含数字和 + ，- , * , / ，其中数字的大小满足 |val| \le 200 。

示例1

```
输入：["2","1","+","4","*"]
返回值：12
```

示例2

```
输入：["2","0","+"]
返回值：2
```

维持一个栈，存储操作数
遇到操作数则入栈
遇到运算符，则从弹出两个操作数进行计算，并将结果再存入栈中
注：这道题的除非运算，必须取整（四舍五入），即用int（b/a），而不能用b//a,双斜杠都是向下取整。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param tokens string字符串一维数组 
# @return int整型
#
class Solution:
    def evalRPN(self , tokens: List[str]) -> int:
        # write code here
        stack = [] # 存储操作数
        for i in tokens:
            if i in "+-*/":
                a = stack.pop()
                b = stack.pop()
                # 加减乘除
                if i == '+':
                    stack.append(b+a)
                elif i == '-':
                    stack.append(b-a)
                elif i == '*':
                    stack.append(b*a)
                else:
                    stack.append(int(b/a)) # 取整，四舍五入
            else:
                stack.append(int(i))
        return stack[0]
```

#### AB5 点击消除

描述
牛牛拿到了一个字符串。
他每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串"abbc"点击后可以生成"ac"。
但相同而不相邻、不相同的相邻字母都是不可以被消除的。
牛牛想把字符串变得尽可能短。他想知道，当他点击了足够多次之后，字符串的最终形态是什么？
输入描述：
一个字符串，仅由小写字母组成。（字符串长度不大于300000）
输出描述：
一个字符串，为“点击消除”后的最终形态。若最终的字符串为空串，则输出0。
示例1

```
输入：abbc
输出：ac
```

示例2

```
输入：abba
输出：0
```

示例3

```
输入：bbbbb
输出：b
```

思路：
step1：创建一个空栈；输入元素；
step2：遍历s，如果栈内元素为0，则直接添加；否则，如果栈内最后一个元素与i相等，则弹出该元素；否则直接添加；
step3：如果栈长度为0，打印0；否则，逐个打印；
代码如下：

```
stack = []
s = input()
for i in s:
    if len(stack) == 0:
        stack.append(i)
    else:
        if stack[-1] == i:
            stack.pop()
        else:
            stack.append(i)
if len(stack) == 0:
    print('0')
else:
    for i in stack:
        print(i,end = '')
```

#### AB6 表达式求值

描述
请写一个整数计算器，支持加减乘三种运算和括号。

数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内

要求：空间复杂度： O(n)O(n)，时间复杂度 O(n)O(n)

示例1

```
输入："1+2"
返回值：3
```

示例2

```
输入："(2*(3-4))*5"
返回值：-10
```

示例3

```
输入："3+2*3*4-1"
返回值：26
```

方法：栈 + 递归（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

对于上述两个要求，我们要考虑的是两点，一是处理运算优先级的问题，二是处理括号的问题。

处理优先级问题，那必定是乘号有着优先运算的权利，加号减号先一边看，我们甚至可以把减号看成加一个数的相反数，则这里只有乘法和加法，那我们优先处理乘法，遇到乘法，把前一个数和后一个数乘起来，遇到加法就把这些数字都暂时存起来，最后乘法处理完了，就剩余加法，把之前存起来的数字都相加就好了。

处理括号的问题，我们可以将括号中的部分看成一个新的表达式，即一个子问题，因此可以将新的表达式递归地求解，得到一个数字，再运算：

终止条件： 每次遇到左括号意味着进入括号子问题进行计算，那么遇到右括号代表这个递归结束。
返回值： 将括号内部的计算结果值返回。
本级任务： 遍历括号里面的字符，进行计算。
具体做法：

step 1：使用栈辅助处理优先级，默认符号为加号。
step 2：遍历字符串，遇到数字，则将连续的数字字符部分转化为int型数字。
step 3：遇到左括号，则将括号后的部分送入递归，处理子问题；遇到右括号代表已经到了这个子问题的结尾，结束继续遍历字符串，将子问题的加法部分相加为一个数字，返回。
step 4：当遇到符号的时候如果是+，得到的数字正常入栈，如果是-，则将其相反数入栈，如果是*，则将栈中内容弹出与后一个元素相乘再入栈。
step 5：最后将栈中剩余的所有元素，进行一次全部相加。
图示：

![50428EF40C2A491EE09E9D953F1B83C2](/Users/zzy/Downloads/Chrome下载/50428EF40C2A491EE09E9D953F1B83C2.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回表达式的值
# @param s string字符串 待计算的表达式
# @return int整型
#
class Solution:
    def solve(self , s: str) -> int:
        # write code here
        s = s.strip()
        stack = []
        res = 0
        num = 0
        sign = "+"
        index = 0
        while index < len(s):
            if s[index] == " ":
                index += 1
                continue
            # 遇到左括号
            if s[index] == "(":
                end = index + 1
                lens = 1
                while lens > 0:
                    if s[end] == "(":
                        lens += 1
                    if s[end] == ")":
                        lens -= 1
                    end += 1
                #将括号视为子问题进入递归
                num = self.solve(s[index + 1:end - 1])
                index = end - 1
                continue
            #字符数字转换成int数字
            if '0' <= s[index] <= '9':
                num = num * 10 + int(s[index])
            if not '0' <= s[index] <= '9' or index == len(s) - 1:
                #加
                if sign == '+':
                    stack.append(num)
                #减，加相反数
                elif sign == '-':
                    stack.append(-1 * num)
                #乘优先计算
                elif sign == '*':
                    stack.append(stack.pop() * num)
                num = 0
                sign = s[index]
            index += 1
        #栈中元素相加
        while stack:
            res += stack.pop()
        return res
```

