# [算法入门](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=308)

## 01数据结构

### 栈

#### AB1【模板】栈

描述
请你实现一个栈。
操作：
push x：将 加x\x 入栈，保证 x\x 为 int 型整数。
pop：输出栈顶，并让栈顶出栈
top：输出栈顶，栈顶不出栈
输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。

输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若栈为空，则输出 "error“
否则按对应操作输出。

示例1

```
输入：
6
push 1
pop
top
push 2
push 3
pop

输出：
1
error
3
```

思路
step1：首先初始化栈（第1至13行）
step2：创建栈s，同时输入执行命令次数，按次数执行指令；
step3：按照题目要求，满足要求；
代码如下：

```
class Stack():
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def push(self,item):
        self.items.append(item)
    def pop(self):
        return self.items.pop()
    def peek(self):
        return self.items[len(self.items) - 1]
    def size(self):
        return self.items[len(self.items)]
    
s = Stack()
num = int(input())
for i in range(num):
    a=input()
    if a[0:4] == 'push':
        b = a.split(' ')
        s.push(int(b[1]))
    if a == 'pop':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
            s.pop()
    if a == 'top':
        if s.isEmpty() == True:
            print('error')
        else:
            print(s.peek())
```

#### AB2 栈的压入、弹出序列

描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
1. 0<=pushV.length == popV.length <=1000
2. -1000<=pushV[i]<=1000
3. pushV 的所有数字均不相同
示例1

示例1

```
输入：[1,2,3,4,5],[4,5,3,2,1]
返回值：true
说明：可以通过push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true   
```

示例2

```
输入：[1,2,3,4,5],[4,3,5,1,2]
返回值：false
说明：由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false      
```

方法一：辅助栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

题目要我们判断两个序列是否符合入栈出栈的次序，我们就可以用一个栈来模拟。对于入栈序列，只要栈为空，序列肯定要依次入栈。那什么时候出来呢？自然是遇到一个元素等于当前的出栈序列的元素，那我们就放弃入栈，让它先出来。

```
//入栈：栈为空或者栈顶不等于出栈数组
while(j < n && (s.isEmpty() || s.peek() != popA[i])){
    s.push(pushA[j]);
    j++;
}
```

具体做法：

step 1：准备一个辅助栈，两个下标分别访问两个序列。
step 2：辅助栈为空或者栈顶不等于出栈数组当前元素，就持续将入栈数组加入栈中。
step 3：栈顶等于出栈数组当前元素就出栈。
step 4：当入栈数组访问完，出栈数组无法依次弹出，就是不匹配的，否则两个序列都访问完就是匹配的。
图示：

![7F25B229A4900F6E066BE03E92B0492E](/Users/zzy/Downloads/Chrome下载/7F25B229A4900F6E066BE03E92B0492E.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        n = len(pushV)
        #辅助栈
        s = []
        #遍历入栈的下标
        j = 0
        #遍历出栈的数组
        for i in range(n):
            #入栈：栈为空或者栈顶不等于出栈数组
            while j < n and (len(s) == 0 or s[-1] != popV[i]):
                s.append(pushV[j])
                j += 1
            #栈顶等于出栈数组
            if s[-1] == popV[i]:
                s.pop()
            #不匹配序列
            else:
                return False
        return True
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏情况下需要遍历两个数组各一次
空间复杂度：O(n)O(n)O(n)，辅助栈空间最大为一个数组的长度

方法二：原地栈（扩展思路）
思路：

方法一我们使用了一个辅助栈来模拟，但是数组本来就很类似栈啊，用下标表示栈顶。在方法一种push数组前半部分入栈了，就没用了，这部分空间我们就可以用来当成栈。原理还是同方法一一样，只是这时我们遍历push数组的时候，用下标n表示栈空间，n的位置就是栈顶元素。

具体做法：

step 1：用下标n表示栈空间，用j表示出栈序列的下标。
step 2：遍历每一个待入栈的元素，加入栈顶，即push数组中n的位置，同时增加栈空间的大小，即n的大小。
step 3：当栈不为空即栈顶n大于等于0，且栈顶等于当前出栈序列，就出栈，同时缩小栈的空间，即减小n。
step 4：最后若是栈空间大小n为0，代表全部出栈完成，否则不匹配。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pushV int整型一维数组 
# @param popV int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsPopOrder(self , pushV: List[int], popV: List[int]) -> bool:
        # write code here
        #表示栈空间的大小，初始化为0
        n = 0
        #出栈序列的下标
        j = 0
        #对于每个待入栈的元素
        for num in pushV:
            #加入栈顶
            pushV[n] = num
            #当栈不为空且栈顶等于当前出栈序列
            while n >= 0 and pushV[n] == popV[j]:
                #出栈，缩小栈空间
                j += 1
                n -= 1
            n += 1
        #最后的栈是否为空
        return True if n == 0 else False
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为数组长度，最坏还是遍历两个数组
空间复杂度：O(1)O(1)O(1)，常数级变量，无额外辅助空间

#### AB3 有效括号序列

描述
给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

数据范围：字符串长度 0\le n \le 100000≤n≤10000
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
示例1

```
输入："()[]{}"
返回值：true
```

示例2

```
输入："[]"
返回值：true
```

示例3

```
输入："([)]"
返回值：false
```

方法：栈（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

括号的匹配规则应该符合先进后出原理：最外层的括号即最早出现的左括号，也对应最晚出现的右括号，即先进后出，因此可以使用同样先进后出的栈：遇到左括号就将相应匹配的右括号加入栈中，后续如果是合法的，右括号来的顺序就是栈中弹出的顺序。

具体做法：

step 1：创建辅助栈，遍历字符串。
step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。
step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。
step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。
step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。
图示：

![4760A3E42ACB7E73D162BE2CD8C2E2C9](/Users/zzy/Downloads/Chrome下载/4760A3E42ACB7E73D162BE2CD8C2E2C9.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return bool布尔型
#
class Solution:
    def isValid(self , s: str) -> bool:
        # write code here
        #辅助栈
        st = []
        #遍历字符串
        for i, char in enumerate(s):
            #遇到左小括号
            if char == '(':
                #期待遇到右小括号
                st.append(')')
            #遇到左中括号
            elif char == '[':
                #期待遇到右中括号
                st.append(']')
            #遇到左大括号
            elif char == '{':
                #期待遇到右大括号
                st.append('}')
            #必须有左括号的情况下才能遇到右括号
            elif (len(st) == 0):
                return False
            #右括号匹配则弹出
            elif (st[-1] == char):
                st.pop()
        #栈中是否还有元素
        return len(st) == 0
```

复杂度分析：

时间复杂度：O(n)O(n)O(n)，其中nnn为字符串长度，遍历整个字符串
空间复杂度：O(n)O(n)O(n)，最坏情况下栈空间中记录整个字符串长度的右括号

#### AB4 逆波兰表达式求值

描述
给定一个逆波兰表达式，求表达式的值。

数据范围：表达式长度满足 1 \le n \le 10^4   ，表达式中仅包含数字和 + ，- , * , / ，其中数字的大小满足 |val| \le 200 。

示例1

```
输入：["2","1","+","4","*"]
返回值：12
```

示例2

```
输入：["2","0","+"]
返回值：2
```

维持一个栈，存储操作数
遇到操作数则入栈
遇到运算符，则从弹出两个操作数进行计算，并将结果再存入栈中
注：这道题的除非运算，必须取整（四舍五入），即用int（b/a），而不能用b//a,双斜杠都是向下取整。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param tokens string字符串一维数组 
# @return int整型
#
class Solution:
    def evalRPN(self , tokens: List[str]) -> int:
        # write code here
        stack = [] # 存储操作数
        for i in tokens:
            if i in "+-*/":
                a = stack.pop()
                b = stack.pop()
                # 加减乘除
                if i == '+':
                    stack.append(b+a)
                elif i == '-':
                    stack.append(b-a)
                elif i == '*':
                    stack.append(b*a)
                else:
                    stack.append(int(b/a)) # 取整，四舍五入
            else:
                stack.append(int(i))
        return stack[0]
```

#### AB5 点击消除

描述
牛牛拿到了一个字符串。
他每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串"abbc"点击后可以生成"ac"。
但相同而不相邻、不相同的相邻字母都是不可以被消除的。
牛牛想把字符串变得尽可能短。他想知道，当他点击了足够多次之后，字符串的最终形态是什么？
输入描述：
一个字符串，仅由小写字母组成。（字符串长度不大于300000）
输出描述：
一个字符串，为“点击消除”后的最终形态。若最终的字符串为空串，则输出0。
示例1

```
输入：abbc
输出：ac
```

示例2

```
输入：abba
输出：0
```

示例3

```
输入：bbbbb
输出：b
```

思路：
step1：创建一个空栈；输入元素；
step2：遍历s，如果栈内元素为0，则直接添加；否则，如果栈内最后一个元素与i相等，则弹出该元素；否则直接添加；
step3：如果栈长度为0，打印0；否则，逐个打印；
代码如下：

```
stack = []
s = input()
for i in s:
    if len(stack) == 0:
        stack.append(i)
    else:
        if stack[-1] == i:
            stack.pop()
        else:
            stack.append(i)
if len(stack) == 0:
    print('0')
else:
    for i in stack:
        print(i,end = '')
```

#### AB6 表达式求值

描述
请写一个整数计算器，支持加减乘三种运算和括号。

数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内

要求：空间复杂度： O(n)O(n)，时间复杂度 O(n)O(n)

示例1

```
输入："1+2"
返回值：3
```

示例2

```
输入："(2*(3-4))*5"
返回值：-10
```

示例3

```
输入："3+2*3*4-1"
返回值：26
```

方法：栈 + 递归（推荐使用）
知识点：栈

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

思路：

对于上述两个要求，我们要考虑的是两点，一是处理运算优先级的问题，二是处理括号的问题。

处理优先级问题，那必定是乘号有着优先运算的权利，加号减号先一边看，我们甚至可以把减号看成加一个数的相反数，则这里只有乘法和加法，那我们优先处理乘法，遇到乘法，把前一个数和后一个数乘起来，遇到加法就把这些数字都暂时存起来，最后乘法处理完了，就剩余加法，把之前存起来的数字都相加就好了。

处理括号的问题，我们可以将括号中的部分看成一个新的表达式，即一个子问题，因此可以将新的表达式递归地求解，得到一个数字，再运算：

终止条件： 每次遇到左括号意味着进入括号子问题进行计算，那么遇到右括号代表这个递归结束。
返回值： 将括号内部的计算结果值返回。
本级任务： 遍历括号里面的字符，进行计算。
具体做法：

step 1：使用栈辅助处理优先级，默认符号为加号。
step 2：遍历字符串，遇到数字，则将连续的数字字符部分转化为int型数字。
step 3：遇到左括号，则将括号后的部分送入递归，处理子问题；遇到右括号代表已经到了这个子问题的结尾，结束继续遍历字符串，将子问题的加法部分相加为一个数字，返回。
step 4：当遇到符号的时候如果是+，得到的数字正常入栈，如果是-，则将其相反数入栈，如果是*，则将栈中内容弹出与后一个元素相乘再入栈。
step 5：最后将栈中剩余的所有元素，进行一次全部相加。
图示：

![50428EF40C2A491EE09E9D953F1B83C2](/Users/zzy/Downloads/Chrome下载/50428EF40C2A491EE09E9D953F1B83C2.gif)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回表达式的值
# @param s string字符串 待计算的表达式
# @return int整型
#
class Solution:
    def solve(self , s: str) -> int:
        # write code here
        s = s.strip()
        stack = []
        res = 0
        num = 0
        sign = "+"
        index = 0
        while index < len(s):
            if s[index] == " ":
                index += 1
                continue
            # 遇到左括号
            if s[index] == "(":
                end = index + 1
                lens = 1
                while lens > 0:
                    if s[end] == "(":
                        lens += 1
                    if s[end] == ")":
                        lens -= 1
                    end += 1
                #将括号视为子问题进入递归
                num = self.solve(s[index + 1:end - 1])
                index = end - 1
                continue
            #字符数字转换成int数字
            if '0' <= s[index] <= '9':
                num = num * 10 + int(s[index])
            if not '0' <= s[index] <= '9' or index == len(s) - 1:
                #加
                if sign == '+':
                    stack.append(num)
                #减，加相反数
                elif sign == '-':
                    stack.append(-1 * num)
                #乘优先计算
                elif sign == '*':
                    stack.append(stack.pop() * num)
                num = 0
                sign = s[index]
            index += 1
        #栈中元素相加
        while stack:
            res += stack.pop()
        return res
```

### 队列

#### AB7 【模板】队列

描述
请你实现一个队列。
操作：
push x：将 x\x 加入队尾，保证 x\x 为 int 型整数。
pop：输出队首，并让队首出队
front：输出队首：队首不出队

输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。

输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若队列为空，则输出 "error“
否则按对应操作输出。
示例1

```
输入：
      6
      push 1
      pop
      front
      push 2
      push 3
      pop
输出：
      1
      error
      2
```

题解 | #【模板】队列#
两个栈来实现队列
核心思路是：栈（先进后出）弹出并压入另一个栈再弹出，完成先进先出

初始化两个栈，一个为输入栈s1，一个为输出栈s2，均使用list()实现
执行push，直接s1.append(x)
执行pop时：
先检查输出栈s2是否为空，不为空直接pop
再检查输入栈s1是否为空，为空则报错error
s1不为空则逐项pop到s2中，最后对s2执行pop
执行front时，和pop类似
先检查输出栈s2是否为空，不为空直接返回栈顶s2[-1]
再检查输入栈s1是否为空，为空则报错error
s1不为空则直接访问首个元素，即s1[0]

```
class Quene(object):
    def __init__(self):
        self.s1 = list() # 输入栈
        self.s2 = list() # 输出栈
    
    def push(self, x):
        self.s1.append(x)
        
    def pop(self):
        if len(self.s2):
            return self.s2.pop()
        if not len(self.s1):
            return 'error'
        for i in range(len(self.s1)):
            self.s2.append(self.s1.pop())
        return self.s2.pop()
    
    def front(self):
        if len(self.s2):
            return self.s2[-1]
        if not len(self.s1):
            return 'error'
        return self.s1[0]
    
    def check(self, d):
        if d == 'pop':
            print(self.pop())
        elif d == 'front':
            print(self.front())
        else:
            self.push(int(d.split()[-1]))

n = input()
tmp = Quene()
for _ in range(int(n)):
    data = input()
    tmp.check(data)
```

#### AB8 【模板】循环队列

描述
请你实现一个循环队列，该循环队列可利用的空间大小等于nn个int型变量的大小。
操作：
push x：将xx加入到循环队列尾端。若循环队列已满，输出"full"(不含引号)，否则不输出任何内容。保证xx为int型整数。
front：输出队首元素，队首不出队。若队列为空，输出"empty"(不含引号)。
pop：输出队首元素，且队首出队。若队列为空，输出"empty"(不含引号)。
输入描述：
第一行输入两个整数n,qn,q (1\le n,q \le 10^51≤n,q≤10 
5
 )，表示循环队列可利用的空间大小和操作次数。
接下来的qq行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。
输出描述：
按对应操作要求输出。
示例1

```
输入：
    3 10
    push 1
    push 2
    front
    push 3
    push 4
    pop
    pop
    pop
    front
    pop

输出：
    1
    full
    1
    2
    3
    empty
    empty
```

题解 | #【模板】循环队列#
基于普通的队列形式，增加队列长度的判断

```
class Cirque():
    def __init__(self):
        self.items = []
        
    def push(self, x):
        return self.items.append(x)
    
    def front(self):
        return self.items[0]
    
    def pop(self):
        return self.items.pop(0)
    
    def size(self):
        return len(self.items)
    
message = input() # 输入行信息
messagesplit = message.split()
n = int(messagesplit[0]) # 循环列表长度
q = int(messagesplit[1]) # 操作次数
s = Cirque()

for i in range(q):
    opo = input()
    oposplit = opo.split(" ")
    if oposplit[0] == 'push':
        if s.size() == n:
            print('full')
        else:
            s.push(oposplit[1])
    elif oposplit[0] == 'front':
        if s.size() == 0:
            print('empty')
        else:
            print(s.front())
    elif oposplit[0] == 'pop':
        if s.size() == 0:
            print('empty')
        else:
            print(s.pop())
    else:
        raise ValueError('无此操作')
```

### 链表

#### AB9 【模板】链表x

描述
请你实现一个链表。
操作：
insert x y：将y加入链表，插入在第一个值为x的结点之前。若链表中不存在值为x的结点，则插入在链表末尾。保证x,y为int型整数。
delete x：删除链表中第一个值为x的结点。若不存在值为x的结点，则不删除。
输入描述：
第一行输入一个整数nn (1≤n≤10^4^)，表示操作次数。
接下来的n行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。
输出描述：
输出一行，将链表中所有结点的值按顺序输出。若链表为空，输出"NULL"(不含引号)。
示例1

```
输入：
      5
      insert 0 1
      insert 0 3
      insert 1 2
      insert 3 4
      delete 4
输出：
      2 1 3
```

```
class linkedlist:
    def __init__(self):
        self.items = []
    
    def insert(self, x ,y):
        if x in self.items:
            loc = self.items.index(x)
            self.items.insert(loc, y)
        else:
            self.items.append(y)
            
    def delete(self, x):
        if x in self.items:
            loc = self.items.index(x)
            self.items.pop(loc)
            
    def size(self):
        return len(self.items)
    
    def traversal(self):
        for i in range(len(self.items)):
            print(self.items[i], end = " ")
            
s = linkedlist()
n = int(input())
for i in range(n):
    message = input()
    messagesplt = message.split(" ")
    if messagesplt[0] == "insert":
        a = messagesplt[1]
        b = messagesplt[2]
        s.insert(a, b)
    elif messagesplt[0] == "delete":
        a = messagesplt[1]
        s.delete(a)
    else:
        raise ValueError("无此操作")
if s.size() == 0:
    print("NULL")
else:
    s.traversal()
```

#### **AB10** **反转链表**

描述
给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0≤n≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n) 。

如当输入链表{1,2,3}时，
经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。
以上转换过程如下图所示：

![4A47A0DB6E60853DEDFCFDF08A5CA249](/Users/zzy/Downloads/Chrome下载/4A47A0DB6E60853DEDFCFDF08A5CA249.png)

示例1

```
输入：
      {1,2,3}
返回值：
      {3,2,1}	
```

示例2

```
输入：
      {}
返回值：
      {}
说明：
      空链表则输出空     
```

描述
这是一篇针对初学者的题解，共用2种方法解决。
知识点：单链表
难度：一星

题解
方法一：构造链表
如果此类型的题出现在笔试中，如果内存要求不高，可以采用如下方法：
可以先用一个vector将单链表的指针都存起来，然后再构造链表。
此方法简单易懂，代码好些。
###代码：

```

```

时间复杂度：O(n)
空间复杂度：O(n), 用了一个vector来存单链表

方法二：正规解法
但是面试的时候，上一种解法当然不行。此题想考察的是：如何调整链表指针，来达到反转链表的目的。
初始化：3个指针
1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向nullptr
2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向head
3）nex指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存
接下来，循环执行以下三个操作
1）nex = cur->next, 保存作用
2）cur->next = pre 未反转链表的第一个节点的下个指针指向已反转链表的最后一个节点
3）pre = cur， cur = nex; 指针后移，操作下一个未反转链表的第一个节点
循环条件，当然是cur != nullptr
循环结束后，cur当然为nullptr，所以返回pre，即为反转后的头结点=

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        # write code here
        pre = None
        phead = head
        while phead:
            temp = phead.next
            phead.next = pre
            pre = phead
            phead = temp
        return pre
```

#### AB11 合并两个排序的链表

描述
输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
数据范围： 0≤n≤1000，-1000≤节点值≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n)

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：

![09DD8C2662B96CE14928333F055C5580](/Users/zzy/Downloads/Chrome下载/09DD8C2662B96CE14928333F055C5580.png)

或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：

![8266E4BFEDA1BD42D8F9794EB4EA0A13](/Users/zzy/Downloads/Chrome下载/8266E4BFEDA1BD42D8F9794EB4EA0A13.png)

示例1

```
输入：
      {1,3,5},{2,4,6}
返回值：
      {1,2,3,4,5,6}
```

示例2

```
输入：
			{},{}
返回值：
			{}
```

示例3

```
输入：
			{-1,2,4},{1,3,4}
返回值：
			{-1,1,2,3,4,4}
```

非递归方法

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self , pHead1: ListNode, pHead2: ListNode) -> ListNode:
        # write code here
        dummy = cur = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val < pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 = pHead2.next
            cur = cur.next
        cur.next = pHead1 or pHead2
        return dummy.next
```

递归方法

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self , pHead1: ListNode, pHead2: ListNode) -> ListNode:
        # write code here
        if not pHead1 or not pHead2:
            return pHead1 or pHead2
        if pHead1.val < pHead2.val:
            pHead1.next = self.Merge(pHead1.next, pHead2)
            return pHead1
        else:
            pHead2.next = self.Merge(pHead1, pHead2.next)
            return pHead2
```

#### AB12 删除链表的节点

描述
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

1.此题对比原题有改动
2.题目保证链表中节点的值互不相同
3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

数据范围:
0<=链表节点值<=10000
0<=链表长度<=10000
示例1

```
输入：
      {2,5,1,9},5
返回值：
      {2,1,9}
说明：
给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -> 1 -> 9   
```

示例2

```
输入：
      {2,5,1,9},1
返回值：
      {2,5,9}
说明：
给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -> 5 -> 9   
```

题目的主要信息：
给定单链表的一个头，删除该链表指定节点
该链表所有元素不同
举一反三：
学习完本题的思路你可以解决如下题目：

JZ76. 删除链表中重复的结点

JZ6. 从尾到头打印链表

方法：迭代遍历（推荐使用）
思路：

既然是整个链表元素都不相同，我们要删除给定的一个元素，那我们首先肯定要找到这个元素，然后考虑删除它。

删除一个链表节点，肯定是断掉它的前一个节点指向它的指针，然后指向它的后一个节点，即越过了需要删除的这个节点。

```
//断开连接
pre.next = cur.next;
```

具体做法：

step 1：首先我们加入一个头部节点，方便于如果可能的话删除掉第一个元素。
step 2：准备两个指针遍历链表，一个指针指向当前要遍历的元素，另一个指针指向该元素的前序节点，便于获取它的指针。
step 3：遍历链表，找到目标节点，则断开连接，指向后一个。
step 4：返回时去掉我们加入的头节点。
图示：

![074232413F62F32D1B2134AF0B9ED494](/Users/zzy/Downloads/Chrome下载/074232413F62F32D1B2134AF0B9ED494.gif)

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param val int整型 
# @return ListNode类
#
class Solution:
    def deleteNode(self , head: ListNode, val: int) -> ListNode:
        # write code here
        res = ListNode(0)
        res.next = head
        #前序节点
        pre = res
        #当前节点
        cur = head
        #遍历链表
        while cur is not None:
            #找到目标节点
            if cur.val == val:
                #断开连接
                pre.next = cur.next
                break
            pre = cur
            cur = cur.next
            #返回去掉头节点
        return res.next
```

### 图论

#### AB13 【模板】拓扑排序

描述
给定一个包含n个点m条边的有向无环图，求出该图的拓扑序。若图的拓扑序不唯一，输出任意合法的拓扑序即可。若该图不能拓扑排序，输出−1。
输入描述：
第一行输入两个整数n,m ( 1≤n,m≤2⋅10^5^ )，表示点的个数和边的条数。
接下来的m行，每行输入两个整数u~i~,v~i~(1≤u,v≤n)，表示u~i~到,v~i~之间有一条有向边。
输出描述：
若图存在拓扑序，输出一行nn个整数，表示拓扑序。否则输出−1。
示例1

```
输入：
      5 4
      1 2
      2 3
      3 4
      4 5
输出：
      1 2 3 4 5
```

```
n, m = map(int, input().split())

graph = dict((str(i),[]) for i in range(1, n+1))
# print(graph)
# 边数
for i in range(m):
    j, k = input().split()
    graph[j].append(k)
# print(graph)

in_degree = dict((i,0) for i in graph)
# print(in_degree)
# 计算入度
for i in graph: # 遍历键 {'1': ['2'], '2': ['3'], '3': ['4'], '4': ['5'], '5': []}
    for j in graph[i]:
        in_degree[j] += 1
        
lis = [i for i in in_degree if in_degree[i] == 0] # 寻找入度为0
res = []

while lis:
    c = lis.pop()
    res.append(c)
    for i in graph[c]:
        in_degree[i] -=1
        if in_degree[i] == 0:
            lis.append(i)
            
if len(res) == n:
    print(" ".join(res))
else:
    print(-1)
```

#### AB14 最小生成树

描述
一个有 n 户人家的村庄，有 m 条路相互连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。

cost 为一个二维数组，每个元素是一个长度为 3 的一维数组 a ， a[0] 和 a[1] 表示村庄 a[0] 和村庄 a[1] 有一条路，修这条路的成本价格为 a[2] .

每户之间可能有多条道路连接，但不可能自己与自己相连

数据范围: 1≤n≤5×10^3^ ， 1 ≤m≤5×10^5^， 1≤a[2]≤10^4^

进阶： 时间复杂度 O(n+mlogm) ， 空间复杂度 O(n)
示例1

```
输入：
      3,3,[[1,3,3],[1,2,1],[2,3,1]]
返回值：
      2
```

示例2

```
输入：
      2,1,[[1,2,1]]
返回值：
			1
```

——首先具体连接图如图A所示，权值在图上的点与点之间的线上所标，刚开始找出最小的两点之间的权值为{V1，V3}，将V1与V3相连接形成图B，下面搜索与V3所连接的最小权值，据图发现，权值为4，所以连接{V3，V6}，形成图C，搜索与V6所连接的最小权值图为V4，将V6与V4相连接，形成图D，因为此时V4与周围的结点已经建立了连接了，所以向上返回到V6，V6与V4性质相同，向上返回到V3，寻找与V3最近且未连接的结点为V2，将V3与V2相连接，循环到V2，与V2最近的节点为V5，由此生成了一个最小值的树，最终将所有的值相加即可返回最近的值。这就是prim算法的具体步骤。

——在具体分析的过程中，首先将所有的数据添加到list链表当中，其次，一直通过循环来建立点与最小权值且可连接的边的点，建立完成之后，停止循环。所以其时间复杂度为O(N^2^)，因为构建了两个存储空间，一个用来存储最终的边，另一个用来存储最终的点，所以空间复杂度为O(N+M)。

——克鲁斯卡尔算法的核心是始终在图中寻找最短路径，如图A所示，第一条最短路径为1，连接点的双方为{V1，V3}，第二条最短路径的权值为2，连接点的双方为{V4，V6}，第三条最短路径为3，连接点的双方为{V2，V5}，第四条最短路径为4，连接点的双方为{V3，V6}，最后一条的权值为5，连接双方为{V2，V3}，最终形成和普里姆算法相同的图。

——克鲁斯卡尔算法的核心是通过对所有边权值大小进行排序，然后按照从大到小进行遍历，如果不能使现有的图成环的话就将边加入，然后将权值算入res中，一旦成环，就结束，在该算法中，有一种排序为对边进行排序，因为边数为M，所以对边进行排序的时间复杂度为O(MlogM)，总的时间复杂度为O(N+MlogM)，N为点，M为边，创建了一个p的内存空间，用来存储点和访问过的路径，所以其空间复杂度为O(N+M*2)。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回最小的花费代价使得这n户人家连接起来
# @param n int整型 n户人家的村庄
# @param m int整型 m条路
# @param cost int整型二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
# @return int整型
#

class Union:
    def __init__(self, n: int):
        self.parent = [0 for _ in range(n + 1)]
        self.rank = [0 for _ in range(n + 1)]
        self.count = n
        for i in range(n + 1):
            self.parent[i] = i
            self.rank[i] = 1
            
    def find(self, x):
        if x == self.parent[x]:
            return x
        return self.find(self.parent[x])
    
    def union(self, x, y):
        xi, yi = self.find(x), self.find(y)
        if xi == yi:
            return
        if self.rank[xi] > self.rank[yi]:
            self.parent[yi] = xi
            self.rank[xi] += self.rank[yi]
        else:
            self.parent[xi] = yi
            self.rank[yi] += self.rank[xi]
        self.count -= 1
        
    def connection(self, x ,y):
        xi ,yi = self.find(x), self.find(y)
        return xi == yi
        
    def count(self):
        return self.count          
    
class Solution:
    def miniSpanningTree(self , n: int, m: int, cost: List[List[int]]) -> int:
        # write code here
        union = Union(n)
        cost.sort(key = lambda x: x[2])
        res = 0
        for a, b, w in cost:
            if union.connection(a, b):
                continue
            res += w
            union.union(a, b)
        return res
```

#### AB15 【模板】单源最短路2

描述
给你一个无向图，图中包含 5000 个点 m 个边，任意两个点之间的距离是 w ，无重边或自环。请求出1号点到n号点的最短距离。

注意：图中可能存在孤立点，即存在点与任意点都没有边相连

如果1号点不能到达n号点，输出-1.


输入描述：

```

第一行两个整数n和m，表示图的点和边数。



接下来m行，每行三个整数u，v, w，表示u到v有一条无向边, 长度为w。



1≤n≤5000 1≤m≤50000 1≤w≤10000 
```

输出描述：

```
输出一行，表示1到n的最短路，如不存在，输出-1.
```

示例1

```
输入：
      4 4
      1 2 3
      2 4 7
      3 4 5
      3 1 3
输出：
      8
```

示例2

```
输入：
      4 3
      1 2 5
      2 3 3
      3 1 3
输出：
      -1
说明：
			1号点不能到4号点。
```

